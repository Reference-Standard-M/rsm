 set %i=$io,n=0 read code xecute code use 0 close %i do ^%C kill ^$routine("%C") write !,"Loaded "_n_" routines",! quit
 for  read rou quit:rou=""  use 0 write rou,! use %i kill ln for i=1:1 read ln(i) if ln(i)="" merge ^$routine(rou)=ln set n=n+1 quit
%RR
%RR ;Routine Restore from file
 new FILE
 read "Restore from file: ",FILE,! quit:FILE=""
 do INT(FILE,0) quit
;---
INT(FILE,NOSAY,%,A,R,ZR) new $etrap set ZR="INT^%RR",NOSAY=$get(NOSAY),$etrap="do EX^%RR"
 open 1:(FILE:"read") use 1 read A,R use 0 set A=$translate(A,$char(13)),R=$translate(R,$char(13))
 if NOSAY<2 write !,A,!,R,!
 if 'NOSAY read "Restore N> ",%,! if $extract($&e(%))'="Y" close 1 write "ABORTED",! quit
 use 1 for  read R set R=$translate(R,$char(13)) quit:R=""  do  quit:$ascii($key)=255
 . set R=$piece(R,"^") ;Needed to support ISC Cache routine export format
 . if NOSAY<2 use 0 write:$x>70 ! write R,?$x\10+1*10 use 1
 . kill A for %=1:1 read A(%) set A(%)=$translate(A(%),$char(13)) quit:A(%)=""  quit:$ascii($key)=255
 . merge ^$routine(R)=A
;---
EX use 0 write:R'="" "$ECODE=,"_$piece($ecode,",",2)_","_$&%errmsg($piece($ecode,",",2))
 write:NOSAY<2 ! set $ecode="" use:R'="" 1 if R="" close 1 quit

%RS
%RS ;Routine Save
 read !,"Routine(s): ",ROU quit:ROU=""
 read !,"Filename:   ",FILE goto %RS:FILE=""
 read !,"Header Txt: ",HEAD,! set:HEAD="" HEAD=ROU
 do INT(ROU,FILE,HEAD) quit
;---
INT(ROU,FILE,HEAD,%,VOL,UCI,R,ZR) new $etrap set ZR="INT^%RS",$etrap="do EX^%RS"
 set HEAD=$get(HEAD,ROU)
 set UI=$$UI^%U() kill ^UTILITY(UI) set ROU=$$PAT^%U(ROU)
 do INT^%RD(3,ROU,^$job($job,"routine"),"","z","^UTILITY("_UI_")")
 if $order(^UTILITY(UI,""))="" write !,"?No routines selected.",! quit
 set %=^$job($job,"routine_vol"),VOL=^$system("vol",%,"name")
 set UCI=^$system("vol",%,"uci",^$job($job,"routine"))
 open 1:(FILE:"write") use 1 write "Saved by %RS from ["_UCI_","_VOL_"] on "
 write $$D^%D($horolog)," at ",$$T^%T($piece($horolog,",",2)),!,HEAD,!
 set R="" for  set R=$order(^UTILITY(UI,R)) quit:R=""  do
 . use 0 write:$x>70 ! write R,?$x\10+1*10 use 1 write R,!
 . set %=0 for  set %=$order(^$routine(R,%)) quit:%=""  write ^$routine(R,%),!
 . write !
;---
EX write ! use 0 write:R'="" "$ECODE=,"_$piece($ecode,",",2)_","_$&%errmsg($piece($ecode,",",2))
 set $ecode="" use:R'="" 1 if R="" close 1 write ! quit

%GR
%GR ;Global Restore from file
 read "Restore from file: ",FILE,! quit:FILE=""
 do INT(FILE,0) quit
;---
INT(FILE,NOSAY,%,G,S,ZR) new $etrap set ZR="INT^%GR",NOSAY=$get(NOSAY),$etrap="do EX^%GR"
 open 1:(FILE:"read") use 1 read G,% use 0 set G=$translate(G,$char(13)),%=$translate(%,$char(13))
 if NOSAY<2 write !,G,!,%,!
 if 'NOSAY read "Restore N> ",%,! if $extract($&e(%))'="Y" close 1 write "ABORTED",! quit
 use 1 for  read G,% set G=$translate(G,$char(13)),%=$translate(%,$char(13)) quit:$extract(G)="*"  do  quit:$ascii($key)=255
 . set @G=% if NOSAY<2 use 0 write:$x>70 ! write G,?$x\10+1*10 use 1
 . for  read S,% set S=$translate(S,$char(13)),%=$translate(%,$char(13)) quit:$extract(S)="*"  set:$extract(S)="^" G="" set @(G_S)=%
;---
EX use 0 write:NOSAY<2 ! close 1 quit

%GS
%GS ;Global Save
 read !,"Global(s):  ",GLO quit:GLO=""
 read !,"Filename:   ",FILE goto %RS:FILE=""
 read !,"Header Txt: ",HEAD,! set:HEAD="" HEAD=GLO
 do INT(GLO,FILE,HEAD) quit
;---
INT(GLO,FILE,HEAD,%,VOL,UCI,G,ZR) new $etrap set ZR="INT^%GS",$etrap="do EX^%GS"
 set HEAD=$get(HEAD,GLO)
 set UI=$$UI^%U() kill ^UTILITY(UI) set GLO=$$PAT^%U(GLO)
 do INT^%GD(3,GLO,^$job($job,"global"),"","z","^UTILITY("_UI_")")
 if $order(^UTILITY(UI,""))="" write !,"?No globals selected.",! quit
 set %=^$job($job,"global_vol"),VOL=^$system("vol",%,"name")
 set UCI=^$system("vol",%,"uci",^$job($job,"global"))
 open 1:(FILE:"write") use 1 write "Saved by %GS from ["_UCI_","_VOL_"] on "
 write $$D^%D($horolog)," at ",$$T^%T($piece($horolog,",",2)),!,HEAD,!
 set GLO="" for  set GLO=$order(^UTILITY(UI,GLO)) quit:GLO=""  set G="^"_GLO do
 . use 0 write:$x>70 ! write GLO,?$x\10+1*10 use 1
 . write G,!,$get(@G),! for  set G=$query(@G) quit:G=""  write "("_$piece(G,"(",2,999),!,@G,!
 . write "*",!,"*",!
 write "**",!,"**",! use 0
;---
EX close 1 write ! quit

%BLKDMP
%BLKDMP ;Dump a block to $IO formatted
 new BLK
 write:$x ! for  read "Block Number: ",BLK,! quit:'BLK  do INT(BLK)
 quit
;---
INT(BLK,XX,%,F,I,G,LI,D,DA,BUF,CCC,UCC,K,KEY,DATA,ZR) new $etrap
 ;NOTE: if do INT^%BLKDMP(0,"^GLOB") will set content to ^GLOB
 set ZR="INT^%BLKDMP",BUF="",$etrap="do EXIT^%BLKDMP"
 new VARLEN,HDRSIZE,LONG set VARLEN=$get(^$system("name_length"),8),HDRSIZE=VARLEN+12,LONG=0
 ;NOTE: If BLK ends in +, it will output the full data, not truncate it to 500
 if $extract(BLK,$length(BLK))="+" set LONG=$get(^$system("string_max"),32767),BLK=+BLK
 if BLK view -1:BLK ;Note: BLK=0 means BLK is already in View Buffer
 set %=$view(-1,0) if '% write "Block not in use",! view -1:0 goto EXIT
 if '$data(XX) write "Block: ",$select(BLK:BLK,1:"")," belongs to UCI# ",%#64," "
 set F=^$system("vol",1,"uci",%#64) if '$data(XX) write:$length(F) "(",F,") "
 set D=%\64,G=$&e($view(-1,12,VARLEN),"C") if $data(XX),'D goto EXIT
 if '$data(XX) write $select(G="$GLOBAL":"global directory",D:"data",1:"pointer")," block",!
 set:G="$GLOBAL" D=0
 if '$data(XX) write "Right: ",$view(-1,4,4)," Global: ",G,! write "Index Contains:",!
 set LI=$view(-1,8,2)*2,I=HDRSIZE
 for  do  set I=I+2 quit:I>LI
 . set F=$view(-1,I,2)*4 if 'F write $justify(I,5)_" ..." quit
 . set CCC=$view(-1,F+2),UCC=$view(-1,F+3),%=UCC set:%=1!(%=2) %=3 set:%=4 %=5
 . set:UCC $extract(BUF,CCC+1,999)=$extract($view(-1,F+4,%),1,UCC) set K=BUF,F=F+UCC+4
 . set KEY="" set:$length(BUF) KEY="(" for  set KEY=KEY_$$UNKEY() quit:'$length(K)  set KEY=KEY_","
 . set:$length(BUF) KEY=KEY_")" set:'$length(KEY) KEY="("""")"
 . if '$data(XX) write $justify(I,5)_" "_KEY_"="
 . if 'D set:F#4 F=F\4+1*4 write:'$data(XX) $view(-1,F,4),! quit
 . set K=$view(-1,F,2),F=F+2
 . if 'K set DATA=""
 . else  do
 . . if K<5,K'=3 set DA="" for %=1:1:K set DA=DA_$char($view(-1,F+%-1))
 . . else  set DA=$view(-1,F,K)
 . . set DATA=$$DISP^%U(DA,LONG)
 . if '$data(XX) write """",DATA,"""",! quit
 . set @(XX_KEY_"=DATA")
;---
EXIT if BLK view -1:0 ;Free the GBD if we allocated it
 quit
;---
;Get string from key - check null
UNKEY(C,T,X) if $extract(K,1,2)=$char(0,0) set K=$extract(K,3,999) quit """"""
 ;Check for a string
 if $ascii(K)=128 set C=""""_$piece($extract(K,2,999),$char(0))_"""",K=$piece(K,$char(0),2,999) quit C
 ;Get count
 set C=$ascii(K),K=$extract(K,2,999)
 ;Check for "0"
 if C=64&'K set K=$extract(K,2,999) quit "0"
 ;If it's negative, do the complementing
 if C<64 set C=63-C,T=$translate($piece(K,$char(255)),"0123456789","9876543210"),K=$piece(K,$char(255),2,999)
 ;Extract this (positive) subscript
 else  set T=$piece(K,$char(0)),K=$piece(K,$char(0),2,999)
 ;Quit with the number
 quit $select(C<64:"-",1:"")_$extract(T,1,C#64)_$select($length(T)>(C#64):"."_$extract(T,C#64+1,999),1:"")

%C
%C ;^%C contents
 set ^%C="MCL Version 0.9"
 set ^%C("CD")="do CD^%U(CCL)"
 set ^%C("CD",1)="Change directory (UCI)"
 set ^%C("CLEAR")="write $char(27)_""[H""_$char(27)_""[J"""
 set ^%C("CLEAR",1)="Clear the screen"
 set ^%C("COPY")="merge ^$routine($piece(CCL,"" "",2))=^$routine($piece(CCL,"" ""))"
 set ^%C("COPY",1)="Copy from routine to routine"
 set ^%C("DCHANGE")="do INT^%DED(CCL)"
 set ^%C("DCHANGE",1)="Edit a document using your favorite editor"
 set ^%C("DDIRECT")="do INT^%DD(CCL)"
 set ^%C("DDIRECT",1)="Obtain a document directory"
 set ^%C("DELETE")="do DEL^%RD(CCL,SW)"
 set ^%C("DELETE",1)="Delete [/NOQuery] routine specification"
 set ^%C("DIRECTORY")="xecute ^%C(""RDIRECTORY"")"
 set ^%C("DIRECTORY",1)="Obtain a list of routines - same as RDIRECTORY"
 set ^%C("DSCAN")="do INT^%DED(CCL,1)"
 set ^%C("DSCAN",1)="Scan a document - read-only"
 set ^%C("DUMP")="do INT^%BLKDMP(CCL)"
 set ^%C("DUMP",1)="Dump a block (formatted)"
 set ^%C("EDIT")="do INT^%ED(CCL)"
 set ^%C("EDIT",1)="Edit a routine using your favorite editor"
 set ^%C("ERROR")="do ^%ETDISP"
 set ^%C("ERROR",1)="Display logged errors"
 set ^%C("EXIT")="Internal %M command"
 set ^%C("EXIT",1)="Exit from MCL to either RSM direct mode or OS shell"
 set ^%C("GDIRECTORY")="do INT^%GD(0,CCL)"
 set ^%C("GDIRECTORY",1)="Global directory specification"
 set ^%C("GEFFICIENCY")="do INT^%GE(CCL)"
 set ^%C("GEFFICIENCY",1)="Display storage efficiency of a global"
 set ^%C("GRESTORE")="do INT^%GR(CCL)"
 set ^%C("GRESTORE",1)="Global restore filename"
 set ^%C("GSAVE")="do INT^%GS($piece(CCL,"" ""),$piece(CCL,"" "",2),$piece(CCL,"" "",3,99))"
 set ^%C("GSAVE",1)="Global save specification filename header text"
 set ^%C("HELP")="Internal %M command"
 set ^%C("HELP",1)="This text is displayed"
 set ^%C("LIST")="do INT^%GL(CCL,SW)"
 set ^%C("LIST",1)="List global /D=data only, /L=max level, /M=max lines"
 set ^%C("OS")="set:CCL="""" CCL=""exec $SHELL"" set %=$&%spawn(CCL)"
 set ^%C("OS",1)="Execute OS (Unix) command - shell"
 set ^%C("RDIRECTORY")="do INT^%RD($select(SW[""L"":1,SW[""U"":2,1:0),CCL)"
 set ^%C("RDIRECTORY",1)="Routine directory /FL (first line) or /FU (full) spec"
 set ^%C("ROUCHECK")="do RC^%RD(CCL)"
 set ^%C("ROUCHECK",1)="Check the compile syntax on routine specification"
 set ^%C("RRESTORE")="do INT^%RR(CCL)"
 set ^%C("RRESTORE",1)="Routine restore filename"
 set ^%C("RSAVE")="do INT^%RS($piece(CCL,"" ""),$piece(CCL,"" "",2),$piece(CCL,"" "",3,99))"
 set ^%C("RSAVE",1)="Routine save specification filename header text"
 set ^%C("SCAN")="do INT^%ED(CCL,1)"
 set ^%C("SCAN",1)="Scan a routine - read-only"
 set ^%C("SHOW")="do INT^%SS(CCL)"
 set ^%C("SHOW",1)="Show SYSTEM, LOCKS, or <Job #>"
 set ^%C("SHUTDOWN")="do ^SSD"
 set ^%C("SHUTDOWN",1)="Shutdown the RSM environment"
 set ^%C("STATUS")="do INT^%STA(CCL)"
 set ^%C("STATUS",1)="Show system statistics, specify interval (e.g., STATUS 15)"
 set ^%C("SYSTAT")="do ^%SS"
 set ^%C("SYSTAT",1)="Obtain a system status"
 set ^%C("TYPE")="do 0^%TYP(CCL)"
 set ^%C("TYPE",1)="Type out a routine (like more)"

%D
%D ;Convert %D to printable date
 set:$data(%D)#2=0 %D=+$horolog set %D=$$D(%D) quit
;---
D(D,M,Y,%,ZR) set ZR="D^%D" if D<1!(D>423316) quit ""
 set:D>21608 D=D+1 set M=1,Y=D\1461*4+1841,D=D#1461
 set:'D D=1461,Y=Y-4 for %=1:1:3 quit:D<366  set Y=Y+1,D=D-365
 for %=31,28+(Y#4=0),31,30,31,30,31,31,30,31,30,31 quit:D'>%  set M=M+1,D=D-%
 set M=$piece("Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec",",",M)
 quit $translate($justify(D,2)," ",0)_" "_M_" "_Y

%T
%T ;Convert %T to printable time
 set:$data(%T)#2=0 %T=$piece($horolog,",",2) set %T=$$T(%T) quit
;---
T(H,TYP,M,S,%,ZR) set ZR="T^%T" if H<0!(H>86399) quit ""
 set TYP=$get(TYP,0),%=""
 set S=H#60,H=H\60,M=H#60,H=H\60
 if 'TYP set %=$select(H<12:" AM",1:" PM"),H=H#13+('H*12)+(H>12)
 quit $translate($justify(H,2)," ",0)_":"_$translate($justify(M,2)," ",0)_":"_$translate($justify(S,2)," ",0)_%

%DD
%DD ;Do a document directory
 do INT(".E") quit
;---
INT(PAT,ST,END,G,%,%D,%V,F,R,ZR) set ZR="INT^%DD"
 set FL=$get(FL),PAT=$get(PAT,".E")
 set:PAT="" PAT=".E" if $extract(PAT)'=".",$extract(PAT)'?1N set PAT=$$PAT^%U(PAT)
 write "Document Directory matching '"_PAT_"'.",!! set R=" "
 for ST=0:1 set R=$order(^%D(R)) quit:R=""  if R?@PAT do
 . write R,?30 set END="" set:R["." END=$&e($piece(R,".",$length(R,".")))
 . set %D=^%D(R),%V=0 for  quit:'$order(^%D(%D,%V))  set %V=$order(^(%V))
 . set F=0,%=0 if END="JPG"!(END="GIF")!(END="CLASS") do  quit
 . . for  set %=$order(^%D(%D,%V,%)) quit:'%  set F=F+$length(^(%))
 . . write $justify(F,10)," bytes",!
 . for F=0:1 set %=$order(^%D(%D,%V,%)) quit:'%
 . write $justify(F,10)," lines",!
 quit

%DED
%DED ;Edit a document using $EDITOR
 read !,"Document: ",DOC,! quit:DOC=""  do INT(DOC) quit
;---
INT(DOC,RO,FILE,F,UI,%D,%V,%L,%,ZR) set ZR="^%DED",RO=$get(RO) if $get(DOC)="" quit
 ;Get the index, continue if OK
 set %D=$get(^%D(DOC)) goto CONT:%D
 ;Create if it doesn't exist
 set %D=$order(^%D(" "),-1)+1,^(%D,0)=DOC,^(1,1)="",^%D(DOC)=%D
;---
;Look for a version
CONT set %=$order(^%D(%D,0)),%V=$order(^(%)) if '%V set %V=%+1 do
 . ;Create a new version
 . set %1=0 for %L=1:1 set %1=$order(^%D(%D,%,%1)) quit:'%1  set ^%D(%D,%V,%L)=^%D(%D,%,%1)
 ;Attempt to lock if reqd
 if 'RO lock +^%D(%D):1 else  write !,"?Can't lock document "_DOC,! quit
 ;Setup the file name
 set UI=$$UI^%U(),FILE=DOC_"."_UI open 1:(FILE:"write")
 if 'RO use 1 write "Editing "_DOC,!,"Remove above to NOT save document.",! use 0
 set %=0 use 1 for  set %=$order(^%D(%D,%V,%)) quit:'%  write ^(%),!
 use 0 close 1
 set F=$&%getenv("EDITOR") set:F="" F="vi" set F=F_" "_FILE
 if $extract(F)="x",RO set F=F_"&"
 if $piece(F," ")="vi"
 set %=$&%spawn(F)
 if RO hang 4 open 1:(FILE:"write") close 1 quit
 write !,"Saving edit...",!
 open 1:(FILE:"read") use 1 read F,% use 0
 if "Editing "_DOC'=F write "Edit NOT saved!",! goto EXIT
 ;Save the data
 use 1 set %V=%V+1 for %L=1:1 read F quit:$ascii($key)=255  set ^%D(%D,%V,%L)=F
 ;Remove an old version - done
 set %V=$order(^%D(%D,""),-1),%V=$order(^(%V),-1) if %V set %=$order(^(%V),-1) if % kill ^(%)
;---
EXIT use 0 close 1 open 1:(FILE:"write") close 1 lock -^%D(%D) quit

%ED
%ED ;Edit a routine using $EDITOR
 read !,"Routine: ",ROU,! quit:ROU=""  do INT(ROU) quit
;---
INT(ROU,RO,UI,FILE,F,%,ZR) new $etrap set $etrap="go EXIT^%ED"
 set ZR="^%ED",RO=$get(RO) if $get(ROU)="" quit
 if $get(^$system("name_length"),8)=32 goto CONT:ROU?1A.31AN,CONT:ROU?1"%".31AN&(^$job($job,"routine")=1) quit
 else  goto CONT:ROU?1A.7AN,CONT:ROU?1"%".7AN&(^$job($job,"routine")=1) quit
;---
CONT if 'RO lock +^$routine(ROU):1 else  write !,"?Can't lock routine "_ROU,! quit
 if RO,'$data(^$routine(ROU)) write !,"?No such routine "_ROU,! quit
 set UI=$$UI^%U(),FILE=ROU_"-"_UI_".rsm" open 1:(FILE:"write")
 if 'RO use 1 write "Editing "_ROU,!,"Remove above to NOT save routine.",!,ROU,! use 0
 if '$data(^$routine(ROU)) write !,"Creating routine "_ROU,! use 1 write ROU_" ;New routine",!
 else  set %=0 use 1 for  set %=$order(^$routine(ROU,%)) quit:'%  write ^$routine(ROU,%),!
 write !! use 0 close 1
 set F=$&%getenv("EDITOR") set:F="" F="vi" set F=F_" "_FILE
 if $extract(F)="x",RO set F=F_"&"
 if $piece(F," ")="vi"
 set %=$&%spawn(F)
 if RO hang 4 open 1:(FILE:"write") close 1 quit
 write !,"Saving edit...",!
 open 1:(FILE:"read") kill ^UTILITY(UI) use 1 read F,%,% use 0
 if "Editing "_ROU'=F write "Edit NOT saved!",! goto EXIT
 use 1 for %=1:1 read ^UTILITY(UI,%) quit:^UTILITY(UI,%)=""  quit:$ascii($key)=255
 merge ^$routine(ROU)=^UTILITY(UI) kill ^UTILITY(UI)
;---
EXIT use 0 close 1 open 1:(FILE:"write") close 1 lock -^$routine(ROU) quit

%ET
%ET ;RSM Error Trapper
 ;Don't error trap in here
 new $etrap set $etrap=""
 ;Save $test and $ecode - If we don't have a file, get it
 kill ZZ set ZZ("$T")=$test,ZZ("$ECODE")=$extract($ecode,1,255) if '$data(ZF(1)) do
 . ;Store permanent junk
 . set ZZ("$H")=$horolog,ZZ("$I")=$I,ZZ("$J")=$job,ZZ("$P")=$P,ZZ("$X")=$x,ZZ("$Y")=$y,ZZ("$R")=$R
 . ;Get next number
 . lock +^ERT set ZF(1)=$get(^ERT)+1,^ERT=ZF(1) lock -^ERT
 . ;Setup the global ref
 . set ZF(1)="^ERT("_ZF(1)_",",ZZ=$piece(ZZ("$ECODE"),",",2)
 . ;Set '$ZE' as reason
 . if $length(ZZ) set ZZ("$ZE")=$&%errmsg(ZZ)
 ;Command stack. Store current context and maximum (or current) context level
 set ZZ("$STACK")=$stack-1,ZZ("$STACK(-1)")=$stack(-1),ZZ("$ESTACK")=$estack-1
 ;Save here too
 set ZF(2)=ZZ("$STACK")
 ;Store $STACK($STACK)
 set ZZ("$STACK("_ZF(2)_")")=$stack(ZF(2))
 ;Save where we are up to
 set ZF(1)=$piece(ZF(1),",")_","_ZZ("$ESTACK")_")" merge @ZF(1)=ZZ kill ZZ set ZF=$&%zwrite(ZF(1))
 ;Store remaining information
 for ZZ="PLACE","MCODE","ECODE" set ZZ("$"_ZZ_"()")=$stack(ZF(2),ZZ)
 ;Get the routine name
 set ZZ=$piece($piece($stack(ZF(2),"PLACE"),"^",2)," ") do
 . ;Try to get the first line
 . if $length(ZZ) set ZZ="+1^"_ZZ,ZZ("$ROUTINE")=$text(@ZZ)
 . ;Quit if not set
 . if '$data(ZZ("$R")) quit
 . ;Quit if last subscript null
 . if '$length($qsubscript(ZZ("$R"),$qlength(ZZ("$R")))) quit
 . ;Get extra $R information
 . set ZZ("$D(@$R)")=$data(@ZZ("$R")) if ZZ("$D(@$R)")#2 set ZZ("@$R")=@ZZ("$R")
 ;If RSM, save some more of this
 if $extract(ZF(1))="^" merge @ZF(1)=ZZ kill ZZ,ZF
 ;Quit leaving $ecode set
 quit
;---
;The final Trap entry point - clear $ecode and exit
ZT set $ecode="" quit

%ETDISP
%ETDISP ;RSM Error Display
 ;Save Command Stack, locks etc. - set errortrap to do nothing
 new CS,QV,G,ZR,TER,$etrap set ZR="^%ETDISP",$etrap="do Z^%ET"
 set EG="^ERT"
 write !,?10,"Reference Standard M - Error display utility",!!
 ;Check for transfered errors
 if '$get(@EG) set %=$order(@EG@("Z"),-1) if % set @EG=%
 ;Check for any errors
 if '$get(@EG) kill @EG write ?20,"No errors recorded.",! quit
 set %="" for N=0:1 set ER=%,%=$order(@EG@(%)) quit:'%
 if 'N kill @EG write ?20,"No errors recorded.",! quit
 goto D1:N=1 write N_" error"_$select(N>1:"s",1:0)_" recorded.",!
;---
ER read "Error #: ",ER write ! quit:ER?1A.E
 if ER="?"!(ER="HELP") do  goto ER
 . write ! set ER="" for  set ER=$order(@EG@(ER)) quit:'ER  do S1
 . write ?4,"Enter error number, <Return> for last error, E to EXIT.",!
 . write ?4,"/D to delete the entire error trap global and exit.",!!
 ;Check for a global /D
 if $&e(ER)="/D" kill @EG write !,"deleted...",! quit
 if ER="" set ER=$order(@EG@("z"),-1) set:ER="" ER=" "
 if '$data(@EG@(ER)) write "?No such error number.",! goto ER
;---
;Display 1 error passed in ER
D1 write ! do S1
 ;Say what
 write $get(@EG@(ER,TER,"$ROUTINE")),!,$get(@EG@(ER,TER,"$MCODE()")),!
;---
DV write:$x ! read "Variable: ",V write !
 set V=$&e(V) if $extract(V,1,2)="/D" do  set V="/D"
 . ;Fetch the current $ZE for the /A switch
 . set ERR=$get(@EG@(ER,TER,"$EC"))_": "_$piece($get(^("$ZE")),",",1,2)
 . kill @EG@(ER) if V["/A" set %=0 for  set %=$order(@EG@(%)) quit:'%  do
 . . ;Get Top ERror - just dong if no such
 . . set %1=$order(@EG@(%,"z"),-1) if '%1 kill @EG@(%) quit
 . . ;Dong it - then dong all the same if /A specified
 . . if $get(@EG@(%,%1,"$EC"))_": "_$piece($get(^("$ZE")),",",1,2)=ERR kill @EG@(%)
 . ;If there are no errors left, dong the whole thing - unlock and quit
 . kill:'$order(@EG@(0)) @EG quit
 ;See if there are more errors
 if V="/D" set ER=$order(@EG@(ER),-1) set:'ER ER=$order(^(0)) quit:'ER  goto D1
 quit:ER="EXIT"  goto ER:V=""
 if V="HELP" write ! do  goto DV
 . write ?5,"Enter variable to display. Wild card characters ? and * may be used.",!
 . write ?5,"/D to delete error, /D/A to delete all of this type.",!
 . write ?5,"Press <Return> for 'Err#:' prompt.",!
 . write ?5,"*$R* will display all information about the last global reference.",!
 . write ?5,"$ST* will display the call stack.",!
 . write ?5,"<Help> or HELP for help. EXIT to exit.",!
 . write ?5,"To examine variables HELP and EXIT, use HEL? and EXI? respectively.",!!
 set PAT="" if V'["?",V'["*" do V1 goto DV
 ;go through supplied Pattern char by char and treat ?*" specially
 for %=1:1:$length(V) set F=$extract(V,%),PAT=PAT_$select(F="*":".E",F="?":"1E",F="""":"1""""""""",1:"1"""_F_"""")
 ;Scan all variables at Top ERror
 set V="" for  set V=$order(@EG@(ER,TER,V)) goto DV:V=""  if V?@PAT do V1
;---
;Write out this level
V1 write V,?9," = ",$select($data(@EG@(ER,TER,V)):$$CC(^(V)),1:"<UNDEF>"),!
 ;Display at other levels
 for %=TER-1:-1:0 if $data(@EG@(ER,%,V)) write " @ lev-",%,?9," = ",$$CC(@EG@(ER,%,V)),!
 quit
;---
D0 write !?10,"No "_$select(%=89:"previous",1:"next")_" error - select by number.",!
 goto ER
;---
CC(D,F,%,X) if D?.E1C.E set D=$$DISP^%U(D)
 quit """"_D_""""
;---
;Summarize the error in ER
S1 set TER=$order(@EG@(ER,"z"),-1),%DT=$get(@EG@(ER,TER,"$H"))
 write $justify(ER,3),?4,$$D^%D(+%DT)_" "_$$T^%T($piece(%DT,",",2)),?29
 set %=$get(@EG@(ER,TER,"$ECODE"))_": "_$get(^("$ZE")) write $extract(%,1,55),! quit

%G
%G ;Global Extended Lister [ 06/09/2018 13:37 PM ]
 new  ;General Stack
 set $etrap="do ERR^%G" for  do RGLB quit:%G=""  write ! do GO
;---
EXIT write ! quit
;---
ERR set ER=$piece($ecode,",",2) write !,"Error: ",ER," ",$&%errmsg(ER),! set $ecode="" quit
;---
GO set $etrap="do ERR^%G",%HN=%N if %HN?1"^[".E set %HN="^"_$piece(%HN,"]",$length(%HN,"]"))
 set HGDIFF=$length(%N)-$length(%HN),LWLH=0,LWLEV=0,LWLENG=0
 if '%M,%N_"("=%G,$data(@%N)'=10 write %HN write !,@%N,!
 if $order(@%N@(""))="" quit
 set SHOLEV=%L-(%E>1),GREF=%N_"(",HREF=%HN_"(" do CHILDREN(1) quit
;---
CHILDREN(LEV) new LENGTH,SUBSCR,Z ;Stack Important !
 set $etrap="do ERR^%G"
 set LENGTH=$length(GREF),SUBSCR=$select(LEV'>%L:%B(LEV),1:"")
 if SUBSCR'="",$data(^(SUBSCR))
 else  set SUBSCR=$order(^(SUBSCR))
 for  quit:$$PASTEND  do ACHILD if SUBSCR'="" set SUBSCR=$order(^(SUBSCR))
 quit
;---
ACHILD set $etrap="do ERR^%G"
 set Subs=$$qsubscript(SUBSCR),GREF=GREF_Subs,HREF=HREF_Subs,%D=$data(^(SUBSCR))
 if LEV>SHOLEV,(%D'=10)!(%E=2) do SHOWREF write:%D=10 "pointer" write:%D'=10 "="_^(SUBSCR) write !
 if %D>9,(%E'=2)!(LEV<%L) do DESCEND
 set GREF=$extract(GREF,1,LENGTH),HREF=$extract(HREF,1,LENGTH-HGDIFF)
 set:LEV'>%M SUBSCR="" quit
;---
PASTEND() if SUBSCR="" quit 1
 if LEV>%L quit 0
 if %C(LEV)="" quit (%B(LEV)'="")&(%B(LEV)'=SUBSCR)
 if SUBSCR=%C(LEV) quit 0
 if SUBSCR'["E",SUBSCR=+SUBSCR goto GSE
 if %C(LEV)'["E",%C(LEV)=+%C(LEV) quit 1
 quit SUBSCR]%C(LEV)
;---
GSE if %C(LEV)'["E",%C(LEV)=+%C(LEV) quit SUBSCR>%C(LEV)
 quit 0
;---
SHOWREF ;Show global reference (KEY)
 if LWLEV=LEV write ?LWLH-$length(HREF)+LWLENG,$extract(HREF,LWLENG+1,999)
 else  write HREF set LWLH=$length(HREF),LWLEV=LEV
 write ")" set LWLENG=LENGTH-HGDIFF quit
;---
DESCEND set GREF=GREF_",",HREF=HREF_",",DUMMY=$order(^(SUBSCR,""))
 do CHILDREN(LEV+1) set DUMMY=$order(@($extract(GREF,1,$length(GREF)-1)_")"))
 set LWLEV=0,LWLENG=0 quit
;---
QS(STR) set oet=$etrap,$etrap="do qserr^%G"
 if STR'["E",STR=+STR quit STR
;---
notcn set $etrap=oet,TEMP=STR,STR=""
 for PIECE=1:1:$length(TEMP,"""") set STR=STR_""""""_$piece(TEMP,"""",PIECE)
 set STR=$extract(STR,3,999)
 quit """"_STR_""""
;---
qserr set $ecode="" goto notcn
;---
;READ Global KEY-Mask...
RGLB for  do READ quit:%G=""  quit:%M'<0
 quit
;---
READ read !,"Global ^",%G quit:%G=""  if %G="?" do ^%GD set %M=-2 quit
 do PROC if %M=-2  write *7,"  [Invalid global reference]" quit
 do GDEF if %M=-2  write *7,"  [Invalid global reference]" quit
;---
GDEF set $etrap="do DERR^%G" if '$data(@%N) write "  ???" set %M=-2
 quit
;---
DERR set ER=$piece($ecode,",",2) write:$&%errmsg(ER)'["<SYNTAX>" !,$ecode set %M=-2,$ecode="" quit
;---
PROC if $extract(%G)'="^" set %G="^"_%G
 set %F=0 if %G?1"^(".E quit
 set %F=2 if %G'["(" set %G=%G_"("
 if %G?.E1"," set %E=1
 else  if %G?.E1")" set %E=2,%G=$extract(%G,1,$length(%G)-1)_","
 else  set %E=3
 if '%F set %M=-2 quit
 kill %B,%A set %X=$piece(%G,"(",2,256) set %N=$piece(%G,"("),%NFULL=%N
 set %GLO=$piece(%N,"^",2,$length(%N,"^")) do R quit
;---
R set %M=1,%B=1,%L=0,%P=0 goto RT:%X=""
;---
RRR set %A="" if $extract(%X,%M)="," set %X=$extract(%X,1,%M-1)_""""""_$extract(%X,%M,999)
;---
RR if $extract(%X,%M)="""" for %I=1:1 set %M=%M+1 quit:%M>$length(%X)  if $extract(%X,%M)="""" set %M=%M+1 goto RR
 if $extract(%X,%M)="(" set %P=%P+1,%M=%M+1 goto RR
 if $extract(%X,%M)=")",%P set %P=%P-1,%M=%M+1 goto RR
 if ":,)"'[$extract(%X,%M),$extract(%X,%M)'?1C set %M=%M+1 goto RR
 if $extract(%X,%M)?1P,%P set %M=%M+1 goto RR
 if $extract(%X,%M)=":" goto RE:%A]"" set %A=1_$extract(%X,%B,%M-1),%M=%M+1,%B=%M goto RR
 if $extract(%X,%M)'=",",$extract(%X,%M)'=")",$extract(%X,%M)]"" goto RE
 set %L=%L+1,%B(%L)=$extract(%X,%B,%M-1),%M=%M+1,%B=%M
 do S quit:%M=-2  goto RRR:%M'>$length(%X)
;---
RT for %I=1:1:%L quit:%B(%I)=""!(%C(%I)]"")
 set %M=%I-1 quit
;---
RE set %M=-2 quit
;---
S set %C(%L)="" if %A]"" do  goto S1
 . do S1 set %C(%L)=$select(%B(%L)]"":%B(%L),1:$char(255,255)),%B(%L)=$extract(%A,2,999)
;---
S1 if %B(%L)'["E",%B(%L)=+%B(%L) quit
 if %P=1,%E=2,%M'<$length(%X) do
 . set:%B(%L)?.E1"," %B(%L)=$extract(%B(%L),1,$length(%B(%L))-1),%M=%M-1
 . set %E=3,%B(%L)=%B(%L)_")"
 quit:%B(%L)=""
 set $etrap="do S1ERR^%G" if %B(%L)["%" new %A,%C,%D,%E,%F,%G,%I,%M,%N,%P,%X,%ZT
 set @("%B(%L)="_%B(%L)) quit
;---
S1ERR set ER=$piece($ecode,",",2) write "  "_$piece($&%errmsg(ER),">")_"> in ",%B(%L) set %M=-2,$ecode="" quit

%GD
%GD ;Do a global directory for current UCI
 do INT(0,".E") quit
;---
INT(FL,PAT,UCI,ST,END,G,%,F,L,ZR) set ZR="INT^%GD"
 set FL=$get(FL),PAT=$get(PAT,".E"),UCI=$get(UCI,^$job($job,"global"))
 set:PAT="" PAT=".E" if $extract(PAT)'=".",$extract(PAT)'?1N set PAT=$$PAT^%U(PAT)
 set ST=$get(ST),END=$get(END,"z"),L=ST if UCI set UCI=^$system("vol",1,"uci",UCI)
 if FL=3,'$data(G) set G="SEL"
 if FL-3 write "Global Directory of ["_UCI_"] matching '"_PAT_"'.",!!
 for  set L=$order(^[UCI]$global(L)) quit:L=""!($extract(L)]END)  if L?@PAT do
 . if 'FL write:$x>70 ! write L,?$x\10+1*10 quit
 . if FL=3,$extract(L)'="$" set @G@(L)=""
 quit

%GE
%GE ;Global efficiency
 read !,"Global: ^",G,! quit:G=""  do INT(G) quit
;---
INT(G,%,UCI,B,NB,ALL,FRE,L,TA,TU,SIZ,ISD,ZR) set ZR="INT^%GE"
 set G=$translate(G,"^"),UCI="",A=0,SIZ=^$system("vol",1,"block")
 if G["]" set UCI=$piece(G,"]")_"]",G=$piece(G,"]",2)
 set %="^"_UCI_"$GLOBAL("""_G_""")",TA=0,TU=0
 if '$data(@%) write "Global ^",UCI,G," does not exist",! quit
 set B=@% write "Global efficiency for ^",UCI,G," (",B,")",!
 ;Get all levels
 for L=1:1 view -1:B set ISD=$view(-1,0)>64 do  quit:ISD  set B=NB
 . if 'ISD set %=$view(-1,$get(^$system("name_length"),8)+12,2)*4+2,%=$view(-1,%+1)+2+% set:%#4 %=%\4+1*4 set NB=$view(-1,%,4)
 . write "Level",$justify(L,3),": " set FRE=0
 . for ALL=0:1 quit:'B  view -1:B set B=$view(-1,4,4),FRE=$view(-1,10,2)*2+1-$view(-1,8,2)*2+FRE
 . set ALL=ALL*SIZ,FRE=ALL-FRE write $justify(FRE,12)," bytes used of ",$justify(ALL,12)
 . write $justify(FRE/ALL*100,7,2),"%",! set TA=TA+ALL,TU=TU+FRE
 write "Total:    ",$justify(TU,12)," bytes used of ",$justify(TA,12),$justify(TU/TA*100,7,2),"%",!
 quit

%GL
%GL ;List global
 read "Global: ",CCL,! quit:CCL=""  do INT(CCL,"/M") quit
;---
INT(CCL,SW) set GL=CCL if CCL["/" set Q=0 do
 . for %=1:1:$length(CCL) do
 . . set:$extract(CCL,%)="""" Q='Q if 'Q,$extract(CCL,%)="/" set SW=$get(SW)_$extract(CCL,%,999),GL=$extract(CCL,1,%-1)
 if $extract(GL)'="^" set GL="^"_GL
 if $piece(GL,"(")["$" write "?Can't list an SSVN",! quit
 if $data(@GL)=0 write "?Global undefined",! quit
 set STOP=$extract(GL,$length(GL))=")" set:STOP GL=$extract(GL,1,$length(GL)-1)
 set F=$piece(GL,"(",2,999),GL=$piece(GL,"(")_$select(GL["(":"(",1:""),Q=0 goto NA:F=""
 if $extract(F)'="""" set GL=GL_""""
 for %=1:1:$length(F) do
 . if $extract(F,%)="""" set Q='Q,GL=GL_"""" quit
 . if $extract(F,%)'=","!Q set GL=GL_$extract(F,%) quit
 . set GL=GL_$select($extract(F,%-1)="""":"",1:"""")_","_$select($extract(F,%+1)="""":"",1:"""")
 set:$extract(GL,$length(GL))'="""" GL=GL_"""" set GL=GL_")"
;---
NA set GL=$NA(@GL,999)
 set NS=$qlength(GL),LS=$qsubscript(GL,NS),L1="" set:NS L1=$NA(@GL,NS-1)
 set MAX=100,LEV=999,DO=0,NC=0
 if SW["/D" set DO=1
 if SW["/L" set LEV=+$extract($piece(SW,"/L",2),2,99)
 if SW["/N" set NC=1
 if SW["/M" set MAX=+$extract($piece(SW,"/M",2),2,99)
 set CNT=0 if $data(@GL)#10 write GL,"=",@GL,! set CNT=1
 for  set GL=$query(@GL) quit:GL=""  do  quit:STOP>1
 . if STOP,$NA(@GL,NS-1)'=L1!($qsubscript(GL,NS)]]LS) set STOP=2 quit
 . quit:$qlength(GL)>LEV
 . set F=@GL set:F?.E1C.E&'NC F=$$DISP^%U(F) write:'DO GL,"=" write F,!
 . set CNT=CNT+1 if CNT=MAX set STOP=2
 write:CNT=MAX "** "_MAX_" nodes printed **",! quit

%LPC
%LPC ;WAA-Longitudinal Parity Check ;15-June-2000
;---
;;%LPC Version 1.0
LRC(DATA) ;Main Entry point
 new I,X,CHAR,COUNT,ARRAY,LONGSUM,BITE,LBITE
 set X=0
 for I=1:1:$length(DATA) set CHAR=$extract(DATA,I),CHAR=$ascii(CHAR),CHAR=$$CKBYTE(CHAR),ARRAY(I)=CHAR
 for I=8:-1:1 do
 . new J,CNT
 . set J=0,CNT=0
 . for  set J=$order(ARRAY(J)) quit:J<1  do
 . . set CNT=CNT+$extract(ARRAY(J),I)
 . . quit
 . set COUNT(I)=(CNT#2)
 . quit
 for I=1:1:7 if COUNT(I) set X=X+$select(I=1:64,I=2:32,I=3:16,I=4:8,I=5:4,I=6:2,I=7:1,1:0)
 quit X
;---
CKBYTE(X) ;convert to byte and checkbit
 new Y,I,CK
 set Y="",CK=0
 set Y=$$BYTE(X)
 for I=7:-1:1 if $extract(Y,I) set CK=CK+1
 set Y=Y_('(CK#2))
 quit Y
;---
BYTE(Y) ;convert to byte
 new BYTE
 set BYTE=""
 do LOOP
 quit BYTE
;---
LOOP ;main loop to convert to bit
 new BIT
 if Y=0 quit
 set BIT=Y#2
 set BYTE=BIT_BYTE
 if BIT=0 set Y=Y/2
 if BIT=1 set Y=Y\2
 goto LOOP

%M
%M ;The M Command Language
 new CS,WID,A,BL
 set $ecode="",$etrap="" kill CS
 set WID="terminator="_$char(1,2,4,5,6,7,9,10,11,12,13,14,15,16,18,20,21,22,23,24,25,26,28,29,30,31)
 use 0:("controlc":"delete=both":"escape":"echo":WID)
 write $&v(999,999),$char(27)_"[6n" read A set BL=+$piece($key,"[",2),WID=+$piece($key,";",2) ;Work out Bottom Line and Width
;---
START new CMD
 use 0 new $etrap set $etrap="do ERROR^%M" do READ if $get(CMD)'="EXIT" goto START
 set $ecode="" quit
;---
READ new PMT,%PMT,E,CST,KEY,P,SAV
 set PMT="MCL ["_^$system("vol",1,"uci",^$job($job,"global"))_","_^$system("vol",1,"name",^$job($job,"global_vol"))_"]> "
 set %PMT=$length(PMT),E=$char(27)
 new $estack write $&v(BL,1),!,PMT
 set CST=$get(CS)+1 read CMD set KEY=$key,P=$length(CMD)+%PMT+1 do KEY goto K
;---
AD write $&v(BL-($length(CMD)+%PMT\WID-(P-1\WID)),P-1#WID+1)
;---
RS read *A set KEY=$key if A=127!(A=8) set KEY=127,A=27
 if A<32,A'=27 set KEY=$char(A),A=27
 if A=27 do KEY goto K
 if '(P#WID) write "[B"
 if P>($length(CMD)+%PMT) write $char(A) set CMD=CMD_$char(A),P=P+1 goto RS
 set CMD=$extract(CMD,1,P-%PMT-1)_$char(A)_$extract(CMD,P-%PMT,$length(CMD))
 if '($length(CMD)+%PMT#WID) write E_"["_(P-1\WID+1)_"A"_E_"[2K"_E_"[J"_E_"["_WID_"D"_PMT_CMD
 else  write E_"[J"_$extract(CMD,P-%PMT,$length(CMD))
 set P=P+1 goto AD
;---
K set SAV=BL-($length(CMD)+%PMT\WID)
 if KEY=42!(KEY=45) goto DOIT
 if KEY=33 set P=%PMT+1 goto AD ;<Ctrl><A>
 if KEY=81 set CST=CST-1 set:CST<1 CST=CS+1 set CMD=$get(CS(CST)),KEY=55,P=%PMT+1+$length(CMD) ;<Up>
 if KEY=82 set CST=CST+1 set:CST>(CS+1) CST=1 set CMD=$get(CS(CST)),KEY=55,P=%PMT+1+$length(CMD) ;<Down>
 if KEY=36 set CMD=$extract(CMD,1,P-%PMT-1),KEY=55,P=$length(CMD)+%PMT+1 ;<Ctrl><D>
 if KEY=37 set P=$length(CMD)+%PMT+1 goto AD ;<Ctrl><E>
 if KEY=53 set CMD=$extract(CMD,P-%PMT,$length(CMD)),KEY=55,P=%PMT+1 ;<Ctrl><U>
 if KEY=55 write $&v(SAV,1),E_"[J",$&v(BL-($length(CMD)+%PMT\WID),1),PMT,CMD goto AD ;<Ctrl><W>
 if KEY=58 set CMD="EXIT" goto DOIT ;<Ctrl><Z>
 if KEY=83,P'>($length(CMD)+%PMT) set P=P+1 goto AD ;<Right>
 if KEY=84,P>(%PMT+1) set P=P-1 goto AD ;<Left>
 if KEY=87 set CMD=$extract(CMD,1,P-%PMT-1)_$extract(CMD,P-%PMT+1,$length(CMD)) ;<Delete>
 if KEY=96!(KEY=112) set CMD="HELP" goto DOIT ;<F1>|<Help>
 if KEY=127,P>(%PMT+1) set CMD=$extract(CMD,1,P-%PMT-2)_$extract(CMD,P-%PMT,$length(CMD)),P=P-1 write E_"[D" ;<Backspace>|<Ctrl><H>
 if KEY'=87&(KEY'=127) write $char(7) goto RS
 if P<(%PMT+1) write $char(7) goto RS
 if '($length(CMD)+%PMT+1#WID) write E_"[2K"_E_"[B"_E_"[s"_E_"["_WID_"D"_PMT_CMD_E_"[u"
 else  write E_"[J",$extract(CMD,P-%PMT,$length(CMD))
 goto AD
;---
DOIT write:P'>($length(CMD)+%PMT) $&v($length(CMD)+%PMT\WID+1+BL,1) write !
;---
INT new %,CCL,C,SW
 set CMD=$&e(CMD,"b"),CCL=$piece(CMD," ",2,999),C=$&e($piece(CMD," ")) quit:C=""
 if $get(CS(+$get(CS)))'=CMD set CS=$get(CS)+1,CS(CS)=CMD
 if C?1U do:C="K"  xecute CMD quit
 . quit:CMD["("!($extract(CCL)'="^")  if ($&e(CCL)="^$J")!($&e(CCL)="^$JOB") write "Use SHUTDOWN please.",! set CMD="Q" quit
 . write "KILL entire global: N> "
 . read %,! if $extract($&e(%))'="Y" set CMD="Q"
 if C=$extract("EXIT",1,$length(C)) set CMD="EXIT" quit
 if C=$extract("HELP",1,$length(C)) goto ^%MH
 set SW=$piece(C,"/",2,9),C=$piece(C,"/") set:$length(SW) SW="/"_SW
 set %=C set:'$data(^%C(C)) %=$order(^%C(C)) if $extract(%,1,$length(C))=C new $etrap,BL xecute ^(%) quit
 write "?No such MCL command - try HELP",! quit
;---
KEY if KEY=127 quit
 if $length(KEY)=1 set KEY=$ascii(KEY)+32 quit
 if $length(KEY)=3 set KEY=$ascii(KEY,3)+16 quit
 set KEY=$extract(KEY,3,4)+84 quit
;---
WWW(REQ,DATA) ;Web interface
 quit "Not yet implemented"
;---
ERROR use 0 if $estack<2 set $ecode="" goto %M
 quit:$stack-$stack(-1)  set S=$stack-1 if $ecode[",Z51," write:$x ! write "^C",! quit
 set ER=$piece($ecode,",",2) write:$x ! if $length(ER) write "Error: ",ER," ",$&%errmsg(ER),!
 write "$ST=",S,?10,$stack(S),?20,$stack(S,"place"),!
 write "Code:",?10,$stack(S,"mcode"),! quit

%MH
%MH ;Help on MCL
 write !,E_"[1m"_E_"[4m","M Command Language Help Menu",E_"[0m"," - commands are case-insensitive",!
 write "Enter any M command (short form only) or one of the following:",!!
 set %="@" for  set %=$order(^%C(%)) quit:%'?1U.E  write %,?12,^%C(%,1),!
 write !,"Key usage:  <F1> or <Help> this message",!
 write ?12,"<Up> and <Down> move through entered lines",!
 write ?12,"<Left> and <Right> move in current command",!
 write ?12,"<Ctrl><A> move to begining of line",!
 write ?12,"<Ctrl><D> delete to end of line",!
 write ?12,"<Ctrl><E> move to end of line",!
 write ?12,"<Ctrl><U> delete to begining of line",!
 write ?12,"<Ctrl><W> refresh screen",!
 write ?12,"<Ctrl><Z> exit MCL",!
 quit

%RD
%RD ;Do a routine directory for current UCI or manager %
 do INT(0,".E") quit
;---
LIB do INT(0,"1""%"".E",1,"%","%") quit
;---
INT(FL,PAT,UCI,ST,END,G,%,F,R,ZR) set ZR="INT^%RD"
 new BIG set BIG=$$BIGEND^%U
 set WEB=$piece($device,",",2)=2
 set FL=$get(FL),PAT=$get(PAT,".E"),UCI=$get(UCI,^$job($job,"routine"))
 set:PAT="" PAT=".E" if $extract(PAT)'=".",$extract(PAT)'?1N set PAT=$$PAT^%U(PAT)
 set ST=$get(ST),END=$get(END,"z"),R=ST if UCI set UCI=^$system("vol",1,"uci",UCI)
 if FL=3,'$data(G) set G="SEL"
 if FL-3 write "Routine Directory of ["_UCI_"] matching '"_PAT_"'.",!!
 if FL=2 write "Routine",?10," Size",?20,"Owner",?30,"Compiled",!!
 for  set R=$order(^[UCI]$R(R)) quit:R=""!($extract(R)]END)  if R?@PAT do
 . if 'FL write:$x>70 ! write R,?$x\10+1*10 quit
 . if FL=1 write R,?10,^[UCI]$R(R,1),! quit
 . if FL=2 set F=^[UCI]$R(R,0),%=R do  quit
 . . if $extract(R)="%" set %="%25"_$extract(R,2,9)
 . . if WEB write "<a href=""?$$WWW^%25M&CMD=TYP%20"_%_""">"_R_"</a>" set $x=$length(R)
 . . else  write R
 . . write ?10,$justify($length(F),5),?20
 . . if $get(BIG,0) write $ascii(F,3)*256+$ascii(F,4)
 . . else  write $ascii(F,4)*256+$ascii(F,3)
 . . write ?30
 . . if $get(BIG,0) set %=$ascii(F,5)*256+$ascii(F,6)*256+$ascii(F,7)*256+$ascii(F,8)
 . . else  set %=$ascii(F,8)*256+$ascii(F,7)*256+$ascii(F,6)*256+$ascii(F,5)
 . . write $$D^%D(%)," at "
 . . if $get(BIG,0) set %=$ascii(F,9)*256+$ascii(F,10)*256+$ascii(F,11)*256+$ascii(F,12)
 . . else  set %=$ascii(F,12)*256+$ascii(F,11)*256+$ascii(F,10)*256+$ascii(F,9)
 . . write $$T^%T(%),!
 . if FL=3 set @G@(R)=""
 quit
;---
DEL(CCL,SW,%,R,SEL,OK,ZR) set ZR="DEL^%RD",SW=$get(SW)["/NOQ"
 do INT(3,CCL) set R="",OK=1
 for  set R=$order(SEL(R)) quit:R=""  do:'SW  if OK kill ^$routine(R) if SW write:$x>70 ! write R,?$x\10+1*10
 . write "Delete "_R read " OK: N> ",%,! set OK=$extract($&e(%))="Y"
 write ! quit
;---
RC(CCL,%,R,SEL,ZR) set ZR="RC^%RD"
 do INT(3,CCL) set R=""
 for  set R=$order(SEL(R)) quit:R=""  write:$x ! write R,! set %=$&%rouchk(R)
 quit

%RECOMP
%RECOMP ;Recompile ALL routines
 write !,"Recompiling ALL routines in the current environment (UCI)",!
 set R="" for  set R=$order(^$routine(R)) quit:R=""  write:$x>70 ! write R,?$x\10+1*10 merge ^$routine(R)=^$routine(R)
 write !,"Done",! quit

%SHOWBP
%SHOWBP ;Show current debugging breakpoints
 write "Current breakpoints:",!
 set (ROUTINE,LINE)=""
 for  set ROUTINE=$order($ZBP(ROUTINE)) quit:ROUTINE=""  do
 . for  set LINE=$order($ZBP(ROUTINE,LINE)) quit:LINE=""  do
 . . write ?4,"+"_LINE_"^"_ROUTINE,!
 quit

%SS
%SS ;System Status
 write "Job",?5,"PID",?15,"User",?25,"Pri",?30,"Routine",?40,"Commands",?50
 write "GlobRefs",?60,"Where",!
 set J=0 for  set J=$order(^$job(J)) quit:'J  do  write !
 . new $etrap set $etrap="set $EC="""""
 . write J,?5,^$job(J,"pid"),?15,^$job(J,"owner"),?25,$justify(^$job(J,"priority"),3)
 . write ?30,^$job(J,"routine_name"),?40,$justify(^$job(J,"commands"),8),?50
 . write $justify(^$job(J,"grefs"),8),?60,$extract(^$job(J,"$io",0),1,20)
 write ! quit
;---
INT(J,%,ZR) set ZR="INT^%SS",J=$&e(J) if J="" write "Show LOCKS, SYSTEM or Job#",! quit
 ;SHOW LOCKS
 if $extract("LOCKS",1,$length(J))=J do  quit
 . write "Job Count Reference",! set J=""
 . for  set J=$order(^$lock(J)) quit:J=""  set %=^$lock(J) write $justify(+%,3),$justify($piece(%,",",2),6)," ",J,!
 ;SHOW SYSTEM
 if $extract("SYSTEM",1,$length(J))=J do  quit
 . write "$SYSTEM=",$system,!,"UCI# Name",!
 . ;Dump the UCIs
 . for %=1:1:64 set J=^$system("vol",1,"uci",%) if $length(J) write $justify(%,3),"  ",J,!
 . write "Max: ",^$job," jobs",!
 . write "Vol: ",^$system("vol",1,"name")," in file ",^$system("vol",1,"file"),!
 . write ^$system("vol",1,"size")," x ",^$system("vol",1,"block")/1024," KiB Blocks, "
 . write ^$system("vol",1,"free")," Free.",!
 . set J=^$system("vol",1,"logrd"),%=^$system("vol",1,"phyrd")
 . write "Database reads - Logical: ",J,"  Physical: ",%
 . write:J "  Cache hits: ",$justify((J-%)/J*100,0,2),"%" write !
 ;SHOW JOB #
 write "       Job: "_J if '$data(^$job(J)) write " No such job",! quit
 write "   PID: "_^$job(J,"pid")_"   User: "_^$job(J,"owner")
 write "   Priority: "_^$job(J,"priority"),! set %=^$job(J,"process_start")
 write "Started at: "_$$T^%T($piece(%,",",2))," on ",$$D^%D(%)
 write "  UCI Global: "_^$job(J,"global")_"  Lock: "_^$job(J,"lock")
 write "  Routine: "_^$job(J,"routine"),!
 write "   Routine: "_^$job(J,"routine_name"),"  Commands: ",^$job(J,"commands")
 write " GlobRefs: ",^$job(J,"grefs"),!
 set %=^$job(J,"$reference") if $length(%) write "    Global: ",%,!
 set %=^$job(J,"$stack",^$job(J,"$stack"),"mcode") if $length(%) write "      Code: ",%,!
 write "     Stack: ",^$job(J,"$stack",^$job(J,"$stack"),"place")," (Current)",!
 for %=^$job(J,"$stack")-1:-1:1 write $justify(%,10),": ",^$job(J,"$stack",%,"place"),!
 quit

%STA
%STA ;System Statistics ;V 3.0 05 Jan 2000 10:44 AM
 read !,"Interval: ",INT,! quit:INT<1  do INT(INT) quit
;---
INT(INT,%,O,N,EX,I,LS,ZR) new $etrap set ZR="INT^%STA",$etrap="do ERR^%STA",EX=0
 set LS="dbget,dbset,dbkil,dbdat,dbord,dbqry,lasttry,lastok,logrd,phyrd,logwt,phywt"
 write $&v(1,1),$char(27)_"[J" set:'INT INT=1
 do GET quit:EX  merge O=N for  do GET quit:EX  do PRT merge O=N quit:EX  read *%:INT
 write $&v(23,1),! quit
;---
ERR goto ^%ET:$ecode'["Z51" set $ecode="",EX=1 quit
;---
GET for I=1:1:$length(LS,",") set N($piece(LS,",",I))=^$system("vol",1,$piece(LS,",",I))
 set N=$horolog quit
;---
PRT write $&v(1,1),"System Statistics - ",$$T^%T($piece($horolog,",",2))
 write " ("_INT_" secs)",!
 write "Volume: ",^$system("vol",1,"name")
 write " in file: ",^$system("vol",1,"file"),!
 write ^$system("vol",1,"size")," x ",^$system("vol",1,"block")/1024," KiB blocks - "
 write ^$system("vol",1,"free")," available ("
 write $justify(^$system("vol",1,"free")/^$system("vol",1,"size")*100,0,2),"%)",!!
 write ?15,$justify("Total",10),?30,$justify("Increment",10),!
 for I=1:1:$length(LS,",") set %=$piece(LS,",",I) write %,?15,$justify(N(%),10),?30,$justify(N(%)-O(%),10),!
 write "cache",?15,$justify(N("logrd")-N("phyrd")/N("logrd")*100,10,2),"%",?30
 set %=N("logrd")-O("logrd") if '% write $justify("",11),!
 else  write $justify(%-(N("phyrd")-O("phyrd"))/%*100,10,2),"%",!
 quit

%TYP
%TYP ;Type a routine
;---
 ;Type routine ROU
0(ROU,%,%1,F,L,W,S,STOP,ZR) set STOP=0,E=$char(27)
 ;Check it
 if '$data(^$routine(ROU)) write "?No such routine as "_ROU,! quit
 ;Get the size
 set S=$order(^$routine(ROU,""),-1)
 ;Get term setup - clear $y (there needs to be a better way)
 set L=99999,W=999,$y=1 if $piece($device,",",2)=4 set L=24,W=80
 ;Get each line in turn
 for %=1:1 quit:'$data(^$routine(ROU,%))  set F=^$routine(ROU,%) do  quit:STOP
 . ;Format it
 . set:$extract(F)'=";" %1=$piece($piece(F," "),"("),F=%1_$justify("",9-$length(%1))_$piece(F,$select($length(%1):%1,1:" "),2,9999)
 . ;For each bit
 . for  quit:$extract(F,2,99)?." "  do:$y'<L  quit:STOP  write $extract(F,1,W),! set F="_"_$extract(F,W+1,9999)
 . . ;See if we need a continue - setup for a ^C
 . . new $etrap set $etrap="set $EC="""",STOP=1"
 . . ;Do a fancy prompt and get a response
 . . write E_"[7m"_ROU_" ("_$justify(%/S*100,0,0)_"%)"_E_"[0m" read *%1
 . . ;Check for a return
 . . write *13,E,"[K" if %1=13!(%1=10) quit
 . . ;Check for a quit (or ^Z)
 . . if %1=81!(%1=113)!(%1=26) set STOP=1 quit
 . . ;All else is another page
 . . set $y=1
 quit

%U
%U ;General Utilities
UI(%,ZR) set ZR="UI^%U"
 lock +^%AUTH("ui") set %=$get(^%AUTH("ui"))+1,^("ui")=% lock -^%AUTH("ui") quit %
;---
DISP(S,L,%,C,F,ZR,LIM) set ZR="DISP^%U",F=""
 ;Return S (which contains control characters) as displayable string
 set LIM=$select($get(L):L,1:500)
 ;Process each character in the input string
 for %=1:1:$length(S) set C=$ascii(S,%) do  if $length(F)>LIM set F=F_"..." quit
 . ;If it's a normal printable character, add to F and quit
 . if C>31,C<127 set F=F_$char(C) quit
 . ;Look after the normal controls
 . if C<32 set F=F_"<"_$select('C:"Nul",C=8:"Tab",C=10:"LF",C=12:"FF",C=13:"CR",1:"^"_$char(C+64))_">" quit
 . ;and delete - all below 128 now done
 . if C=127 set F=F_"<Del>" quit
 . ;For control characters 128 to 139, enclose in << >>
 . if C<140 set F=F_$char(171)_"^"_$char(C+64)_$char(187) quit
 . ;Assume a "normal" eight bit character
 . set F=F_$char(C)
 ;Quit with result
 quit F
;---
;Create a pattern match from wildcards
PAT(STR,S,N,C,P,ZR) set ZR="PAT^%U"
 set P="" for  quit:STR=""  set S=$piece(STR,","),STR=$piece(STR,",",2,99) if $length(S) set P=P_"," do
 . for N=1:1:$length(S) set C=$extract(S,N),P=P_$select(C="*":".E",C="?":"1E",C="""":"1""""""""",1:"1"""_C_"""")
 set P=$extract(P,2,999) set:P["," P="1("_P_")" quit P
;---
CD(UCI,%,ZR) set ZR="CD^%U"
 ;Make it into a number if possible
 if 'UCI for %=1:1:64 if ^$system("vol",1,"uci",%)=UCI set UCI=% quit
 ;Validate it
 goto CDE:UCI<1!(UCI>64),CDE:'$length(^$system("vol",1,"uci",UCI))
 ;Set all the bits
 for %="GLOBAL","LOCK","ROUTINE" set ^$job($job,%)=UCI
 quit
;---
CDE write !,"?Invalid UCI specified",! quit
;---
BIGEND() ;Is machine big-endian?
 quit $get(^$system("big_endian"),0)

%WWW
%WWW ;WWW Stuff
 new PORT,JOBS
 ;Open the server port - default to port 80 and 5 jobs
 set PORT=80,JOBS=5 goto OPEN
;---
START(PORT,JOBS) ;Pass in port and max jobs to fork
OPEN ;Pass through from top using defaults
 new $etrap,MJN set $etrap="do %ET^%WWW",MJN=$job
 open 10:($get(PORT,80):"server="_$get(JOBS,5))
;---
;Get a message
READ do RECV^%WWW1(.AA)
 ;Look for a GET
 for %=1:1 goto ERR:'$data(AA(%)) if $extract(AA(%),1,5)="GET /" quit
 ;Extract file specification
 set FILE=$piece($extract(AA(%),6,99999)," HTTP/1.") set:FILE="" FILE="index.html"
 ;Log it if applicable
 set %=$get(^WWWLOG) if % set ^WWWLOG(%)=$horolog_","_$piece(DEVICE,",",3)_","_FILE,^WWWLOG=%+1
 ;Look after extrinsics elsewhere
 if $extract(FILE)="?" goto EXT
;---
;Check for % characters
FILE if FILE["%" set FILE=$$REMP(FILE)
 ;Extract just the file name, also get the extension (in upper case)
 set F=$piece(FILE,"/",$length(FILE,"/")),EXT="" set:F["." EXT=$&e($piece(F,".",$length(F,".")))
 ;Get the reference, if no such, give error and exit
 set REF=$$GETFILE(F) if REF="" do ERR^%WWW1() halt:MJN-$job  goto READ
 ;Send it
 do SEND^%WWW1(REF,EXT) halt:MJN-$job  goto READ
;---
;Extrinsic functions - extract the function name
EXT set FUN=$piece($extract(FILE,2,999),"&"),FUN=$$REMP(FUN),FILE=$piece(FILE,"&",2,9999)
 ;Extract the fields
 kill BB for  quit:FILE=""  set F=$piece(FILE,"&"),FILE=$piece(FILE,"&",2,9999) do
 . ;Store one field
 . set I=$piece(F,"="),F=$piece(F,"=",2,999),I=$$REMP(I) set:$length(I) BB(I)=$$REMP(F)
 ;Setup the extrinsic and execute it
 set FUN="RET="_FUN_"(.AA,.BB)" do  if $length(RET) do ERR^%WWW1(RET) halt
 . ;Saving the error trap
 . new $etrap set $etrap="do %ET^%WWW",@FUN
 ;Display a file if required
 if $get(AA)'="" set FILE=AA goto FILE
 ;Done
 halt:MJN-$job  goto READ
;---
;Extrinsic error trap
%ET new F set F=$piece($ecode,",",2),F="RSM Error: "_F_" "_$&%errmsg(F)
 if (F["Z51")!(F["Z42")!(F["Z213") close 10 use 0 write F,! set $ecode="" quit
 if F["Z49" set $ecode="" hang 1 goto LOOP^%WWW1
 do ERR^%WWW1(F) goto ^%ET
;---
;Give error and halt
ERR do ERR^%WWW1("Invalid HTTP message received") use 10:("disconnect") close 10 halt:MJN-$job  goto READ
;---
;Lookup a file in %D
GETFILE(F,%,V,ZR) set ZR="GETFILE^%WWW"
 ;Lookup the file
 set %=$get(^%D(FILE)) quit:'% ""
 ;Get the version
 set V=$order(^%D(%,""),-1) quit:'V ""
 ;Quit with the ref
 quit "^%D("_%_","_V_")"
;---
;Remove %nn stuff from a string
REMP(F,%,X,ZR) set ZR="REMP^%WWW",X=""
 ;Doit
 for  set %=$F(F,"%") quit:'%  set X=X_$extract(F,1,%-2)_$$CC($extract(F,%,%+1)),F=$extract(F,%+2,99999)
 ;and quit
 quit X_F
;---
;Convert Hex to Character
CC(H,%,ZR) set ZR="CC^%WWW",H=$&e(H)
 ;Setup the 'HEX' array 0 -> F
 for %=0:1:15 set %(%)=% set:%>9 %($char(55+%))=%
 ;Quit with decimal value
 quit $char(%($extract(H))*16+%($extract(H,2)))

%WWW1
%WWW1 ;WWW Stuff - subroutines
;---
;Get into D which must be passed by ref, number of lines returned in D
RECV(D,%,N,TO,ZR) set ZR="RECV^%WWW1" kill D set TO=10,D=1
LOOP ;Entry point for error handler when job table is full
 ;Read first (no timeout) then the rest
 use 10 read D(1) set DEVICE=$device if D(1)'="" for D=2:1 read D(D):TO quit:D(D)=""
 ;Clean up the request info
 kill D(D) set D=""
 set N=$get(^WWW) if N for %=1:1 quit:'$data(D(%))  set ^WWW(N+%-1)=D(%)
 if N set ^WWW=N+%-1
 ;and exit
 quit
;---
; REF -> Global ref to send, sends @REF@(n)
; TYP -> HTML  = text/html (default)
;        JS    = text/javascript
;        CSS   = text/css
;        JPG   = image/jpeg
;        GIF   = image/gif
;        CLASS = class
; HTTP/1.1 200 OK
; Content-Type: (as above)
; Content-Length: (length in bytes)
; <blank line>
; File
SEND(REF,TYP,%,L,ZR) new $etrap set ZR="SEND^%WWW1",$etrap="do X^%WWW1",TYP=$get(TYP),L=0
 use 10 new TYPE set TYPE=""
 ;Get TYP into browser format
 set TYPE=$select(TYP="JPG":"image/jpeg",TYP="PNG":"image/png",TYP="GIF":"image/gif",TYP="CLASS":"class",1:TYPE)
 set:TYPE="" TYPE=$select(TYP="CSS":"text/css",TYP="JS":"text/javascript",1:"text/html")
 ;Send HTTP response headers
 write "HTTP/1.1 200 OK",!
 write "Date: "_$$D^%D($horolog)_"  "_$$T^%T($piece($horolog,",",2)),!
 write "Server: Reference Standard M V"_$$VERSION^%ZOSV_" HTTP Server",!
 write "Content-Type: "_TYPE write:$extract(TYPE,1,4)="text" "; charset=iso-8859-1"
 write !
 ;Calculate the total length
 set %=0 for  set %=$order(@REF@(%)) quit:'%  set L=L+$length(@REF@(%))
 write "Content-Length: "_L,!
 ;Terminate header, output file (terminate text lines with CRLF)
 write ! set %=0 for  set %=$order(@REF@(%)) quit:'%  write @REF@(%) write:'L !
 ;and exit
 quit
;---
X if $get(MJN)=$job set $ecode="" quit
 halt:$ecode["Z47"  goto ^%ET
;---
;Send an error message - ensure there is a message
ERR(ERR,%,MSG,ZR) set ZR="ERR^%WWW1",ERR=$get(ERR,"File not found")
 ;Setup the error message
 set MSG(1)="<html><body onLoad=""alert('"_ERR_"'); history.back(); return false""></body></html>"
 ;Send it and quit
 do SEND("MSG") quit

%WWWU
%WWWU ;Web Utilities
 new %D,%L,BS,CH,EXT,F,N,S,OPT,$etrap set $etrap="do ^%ET",U="|"
 set OPT(1)="Edit a document|^%DED",OPT(2)="List documents|^%DD"
 set OPT(3)="Delete a document|DEL",OPT(4)="Import a document|IMP"
;---
START write !,"RSM Web Utilities",!
 for %=1:1 quit:'$data(OPT(%))  write %,". ",$piece(OPT(%),U),!
 read "Option: ",F,! set F=$extract($&e(F)) quit:F=""
 if 'F for %=1:1 quit:'$data(OPT(%))  if $extract(OPT(%))=F set F=% quit
 if 'F write "?Invalid option",$char(7),! goto START
 do @$piece(OPT(F),U,2) goto START
;---
;Delete a documment
DEL read "Enter Name of document to delete: ",F,! quit:F=""!F
 if '$data(^%D(F)) write "?No such document",$char(7),! goto DEL
 set %=^%D(F) kill ^%D(F),^%D(%) write "Deleted.",! quit
;---
;Import a document
IMP read "Enter Name of document to import: ",F,! quit:F=""!F
 ;Get Name, ensure doesn't exist
 set N=$piece(F,"/",$length(F,"/")) if $data(^%D(N)) write "?Document "_N_" exists"_$char(7),! goto IMP
 ;Get block size and the extension
 set BS=^$system("vol",1,"block")-40,EXT="" if N["." set EXT=$&e($piece(N,".",$length(N,".")))
 ;Open the file
 set CH=0 do  if 'CH write "?File "_F_" does not exist"_$char(7),! goto IMP
 . ;Ignore errors
 . new $etrap set $etrap="set $EC=""""" close 1 open 1:(F:"read") set CH=1
 ;Get size
 set S=$&%file(F,"size") if 'S write "?File "_F_" is empty"_$char(7),! goto IMP
 ;Create the document
 set %D=$order(^%D(" "),-1)+1,^%D(%D,0)=N,^(1,1)="",^%D(N)=%D
 ;Check for a binary type
 if EXT="JPG"!(EXT="GIF")!(EXT="CLASS") use 1:("terminator=") set F=S do  quit
 . ;Read in each chunk
 . for %L=1:1 set %=F set:%>BS %=BS set F=F-% read ^%D(%D,1,%L)#% quit:'F
 . ;Finish up
 . close 1 use 0 write S," bytes in ",%L," record",$select(%L>1:"s",1:"")," read.",!
 ;Read in a text file
 use 1 for %L=1:1 read ^%D(%D,1,%L) if $ascii($key)=255 kill:'$length(^%D(%D,1,%L)) ^%D(%D,1,%L) quit
 use 0 close 1 write %L," lines read.",! quit

%X364
%X364 ;Namespace - ANSI X3.64-1979
; Kindly donated by Colin Richardson originally for MUMPS V1
; RSM - this is a subset of the ANSI X3.64 control codes
; Usage: use $io::"%X364" write /CUP(LINE,COL) ;this will position the cursor
; $x and $y are preserved or set as appropriate.
;---
BEL()    write *7 quit  ;Ring Bell (non-standard - but common)
CHA(n)   set n=$get(n,1) write $char(27,91)_n_"G" set $x=n-1 quit  ;Cursor Horizontal Absolute
CHT(n)   set n=$get(n,1) write $char(27,91)_n_"I" set $x=$x\8*8+(n*8) quit  ;Cursor Horiz Tab
CNL(n)   set n=$get(n,1) write $char(27,91)_n_"E" set $y=$y+n quit  ;Cursor Next Line
CPL(n)   set n=$get(n,1) write $char(27,91)_n_"F" set $y=$y-n quit  ;Cursor Preceding Line
CUB(n)   set n=$get(n,1) write $char(27,91)_n_"D" set $x=$x-n quit  ;Cursor Backward
CUD(n)   set n=$get(n,1) write $char(27,91)_n_"B" set $y=$y+n quit  ;Cursor Down
CUF(n)   set n=$get(n,1) write $char(27,91)_n_"C" set $x=$x+n quit  ;Cursor Forward
CUP(x,n) set n=$get(n,1),x=$get(x,1) write $char(27,91)_x_";"_n_"H" set $x=n-1,$y=x-1 quit  ;Cursor Position
CUU(n)   set n=$get(n,1) write $char(27,91)_n_"A" set $y=$y-n quit  ;Cursor Up
CVT(n)   write $char(27,91)_$get(n,1)_"Y" quit  ;Cursor Vertical Tab
DCH(n,x) set x=$x write $char(27,91)_$get(n,1)_"P" set $x=x quit  ;Delete Characters
DCS(x)   set x=$x write $char(27)_"P" set $x=x quit  ;Device Control String
DL(n,x)  set x=$x write $char(27,91)_$get(n,1)_"M" set $x=x quit  ;Delete Lines
EA(n,x)  set x=$x write $char(27,91)_+$get(n)_"O" set $x=x quit  ;Erase in Area
ECH(n,x) set x=$x write $char(27,91)_+$get(n,1)_"X" set $x=x quit  ;Erase Characters
;n=0: cursor to end of screen, n=1: start of screen to cursor, n=2: all screen
ED(n,x)  set x=$x write $char(27,91)_+$get(n)_"J" set $x=x quit  ;Erase Display
EF(n,x)  set x=$x write $char(27,91)_+$get(n)_"N" set $x=x quit  ;Erase Field
;n=0: cursor to end, n=1: start of line to cursor, n=2: whole line
EL(n,x)  set x=$x write $char(27,91)_+$get(n)_"K" set $x=x quit  ;Erase in line
EPA(x)   set x=$x write $char(27)_"W" set $x=x quit  ;End Protected Area
ESA(x)   set x=$x write $char(27)_"G" set $x=x quit  ;End Selected Area
HPA(n)   set n=$get(n,1) write $char(27,91)_n_"`" set $x=n-1 quit  ;Horizontal Position Absolute
HPR(n)   set n=$get(n,1) write $char(27,91)_n_"a" set $x=$x+n quit  ;Horizontal Position Rel
HTJ(x)   set x=$x write $char(27)_"I" set $x=x quit  ;Horizontal Tab w/Justify
HTS(x)   set x=$x write $char(27)_"H" set $x=x quit  ;Horizontal Tab Set
HVP(x,n) set n=$get(n,1),x=$get(x,1) write $char(27,91)_x_";"_n_"f" set $x=n-1,$y=x-1 quit  ;HVP
ICH(n,x) set x=$x,n=$get(n,1) write $char(27,91)_n_"@" set $x=x+n quit  ;Insert CHaracters
IL(n,x)  set x=$x write $char(27,91)_$get(n,1)_"L" set $x=x quit  ;Insert Lines
NEL      write $char(27)_"E" set $x=0,$y=$y+1 quit  ;Next Line
NP(n,x)  set x=$x write $char(27,91)_$get(n,1)_"U" set $x=x quit  ;Next Page
PLD(x)   set x=$x write $char(27)_"K" set $x=x quit  ;Partial Line Down
PLU(x)   set x=$x write $char(27)_"L" set $x=x quit  ;Partial Line Up
PM(x)    set x=$x write $char(27)_"^" set $x=x quit  ;Privacy Message
PP(n,x)  set x=$x write $char(27,91)_$get(n,1)_"V" set $x=x quit  ;Preceding page
PU1(x)   set x=$x write $char(27)_"Q" set $x=x quit  ;Private Use 1
PU2(x)   set x=$x write $char(27)_"R" set $x=x quit  ;Private Use 2
REP(x)   set x=$x write $char(27,91)_"b" set $x=x quit  ;Repeat Character
RI       write $char(27)_"M" set $y=$y-1 quit  ;Reverse Index
RIS      write $char(27)_"c" set $x=0,$y=0 quit  ;Reset to Initial State
RM(n,x)  set x=$x write $char(27,91)_$get(n)_"l" set $x=x quit  ;Reset mode
SGR(n,x) set x=$x write $char(27,91)_$get(n,0)_"m" set $x=x quit  ;Set Graphic Rendition
SPA(x)   set x=$x write $char(27)_"V" set $x=x quit  ;Start Protected Area
SS2(x)   set x=$x write $char(27)_"N" set $x=x quit  ;Single Shift 3
SS3(x)   set x=$x write $char(27)_"O" set $x=x quit  ;Single Shift 3
SSA(x)   set x=$x write $char(27)_"F" set $x=x quit  ;Start Selected Area
ST(x)    set x=$x write $char(27)_"\" set $x=x quit  ;String Terminator
STS(x)   set x=$x write $char(27)_"S" set $x=x quit  ;Set Transmit State
SU(x)    set x=$x write $char(27,91)_"S" set $x=x quit  ;Scroll Up
TBC(n,x) set x=$x write $char(27,91)_$get(n,0)_"g" set $x=x quit  ;Tab Clear
VPA(n)   set n=$get(n,1) write $char(27,91)_n_"d" set $y=n-1 quit  ;Vertical Position Absolute
VPR(n)   set n=$get(n,1) write $char(27,91)_n_"e" set $y=$y+n quit  ;Vertical Position Relative
VTS(x)   set x=$x write $char(27)_"J" set $x=x quit  ;Vertical Tabulation Set

%ZOSV
%ZOSV ;SFISC/AC - View commands & special functions. ;06/09/99  12:54
 ;;8.0;KERNEL;**13,65,71,94,107,118**;Jul 05, 1995
 ;;Originally for MUMPS V1 - RDN, and RSM
 quit
;---
ACTJ(%,CN) ;# active jobs
 set %=0 for CN=0:1 set %=$order(^$job(%)) quit:'%
 quit %
;---
AVJ(%,CN) ;# available jobs
 set %=0 for CN=0:1 set %=$order(^$job(%)) quit:'%
 quit ^$job-%
;---
PASSALL ;
 use $I:("terminator=":"noescape") quit
NOPASS ;
 use $I:("terminator="_$char(13,10):"escape") quit
;---
PRGMODE ;
 write !!,"THIS DOESN'T DO ANYTHING",!! quit
;---
PROGMODE() ;
 quit 1
;---
UCI ;
 new V,U set V=^$job($job,"global_vol"),U=^$job($job,"global"),Y=^$system("vol",V,"uci",U)_","_^$system("vol",V,"name") quit
;---
UCICHECK(X) ;
 new %,%1,U,V,Y
 if '(X?3U!(X?3U1","3U)) quit ""
 if $piece(X,",",2)'="",$piece(X,",",2)'=^$system("vol",1,"name") quit ""
 set U=$piece(X,","),Y="" for %=1:1:64 if ^$system("vol",1,"uci",%)=U set Y=U_","_^$s("vol",1,"name") quit
 quit Y
;---
SHARELIC(TYPE) ;See if can share a C/S license DSM 7.2
 quit
;---
PRIORITY ;
 quit
;---
PRIINQ() ;
 quit ^$job($job,"priority")
;---
BAUD set X="UNKNOWN" quit
;---
LGR() quit $R ;Last global ref.
;---
EC() quit $ecode ;Error code
;---
DOLRO ;SAVE ENTIRE SYMBOL TABLE IN LOCATION SPECIFIED BY X
 set %=$&%zwrite(X) quit
;---
ORDER ;SAVE PARTS OF SYMBOL TABLE IN LOCATION SPECIFIED BY X
 ;PARTS INDICATED BY X1("NAMESPACE*")="" ARRAY
 if $data(X1("*"))#2 do DOLRO quit
 write !!,"THIS DOESN'T DO ANYTHING",!! quit
;---
PARSIZ ;
 set X=3 quit
;---
NOLOG ;
 set Y=0 quit
;---
DEVOPN goto DEVOPN^%ZOSV1
DEVOK  goto DEVOK^%ZOSV1
RES    goto RES^%ZOSV1
;---
GETENV ;Get environment Return Y='UCI^VOL/DIR^NODE^BOX LOOKUP'
 do UCI set Y=$translate(Y,",","^")_"^"_$piece($&%getenv("host"),".")
 set $piece(Y,"^",4)=$piece(Y,"^",2)_":"_$piece(Y,"^",3) quit
;---
VERSION(X) ;return OS version, X=1 - return OS
 if $get(X) quit "Reference Standard M"
 quit $piece($piece($system,"V",2)," ")
;---
SETNM(X) ;Set name, Trap dup's, Fall into SETENV
 new $etrap set $etrap="set $ECODE="""" quit"
SETENV ;Set environment X='PROCESS NAME^ '
 write !!,"THIS DOESN'T DO ANYTHING",!! quit
;---
T0 ;start RT clock
T1 ;store RT datum w/ZHDIF
ZHDIF ;Display dif of two $ZH's
 write !!,"THIS DOESN'T DO ANYTHING",!! quit
;---
LOGRSRC(OPT,TYPE,STATUS) ;record resource usage in ^XTMP("KMPR"
 quit
;---
SETTRM(X) ;Turn on specified terminators.
 use $I:("terminator="_X) quit 1

%ZRCHG
%ZRCHG ;WAA Routine change utility
 new REPLACE,WITH,LINE,CASE,LN,CNT
 set CNT=0
 do ^%ZRSEL
 if '$data(^%UTILITY($job,"ROUTINE")) goto EXIT
 read !,"Replace String: ",REPLACE G:REPLACE="" EXIT
 read !,"With String: ",WITH G:WITH="" EXIT
 set ROUTINE=""
 for  set ROUTINE=$order(^%UTILITY($job,"ROUTINE",ROUTINE)) quit:ROUTINE=""  do
 . new LN,LINE
 . set LN=0
 . for  set LN=$order(^$routine(ROUTINE,LN)) quit:LN<1  do
 . . set (LINE,LINE(ROUTINE,LN))=^$routine(ROUTINE,LN)
 . . if LINE[REPLACE do
 . . . new CON,TOTAL
 . . . write !,"    Routine: ",ROUTINE,"  LINE# ",LN
 . . . write !,"Old: ",LINE set CNT=CNT+1
 . . . set TOTAL=$length(LINE,REPLACE)
 . . . for CON=1:1:TOTAL set $piece(NLINE,WITH,CON)=$piece(LINE,REPLACE,CON)
 . . . set LINE(ROUTINE,LN)=NLINE
 . . . write !,"New: ",NLINE
 . . . quit
 . . quit
 . merge ^$routine(ROUTINE)=LINE(ROUTINE)
 . quit
 write !,CNT," Changes made."
 quit
;---
EXIT ;Clean up
 kill ^UTILITY($job,"ROUTINE")
 do ^%RCOMP
 quit

%ZRS
%ZRS ;Routine Save
 new FILE,HEAD,%,VOL,UCI,UI,R,ZR
 do ^%ZRSEL
 if '$data(^%UTILITY($job,"ROUTINE")) write !,"?No routines selected.",! quit
 read !,"Filename:   ",FILE goto %ZRS:FILE=""
 read !,"Header Txt: ",HEAD,! set:HEAD="" HEAD="No Heading"
 do INT(FILE,HEAD) quit
;---
INT(FILE,HEAD,%,VOL,UCI,UI,R,ZR) new $etrap set ZR="INT^%ZRS",$etrap="do EX^%ZRS"
 set UI=$$UI^%U()
 merge ^UTILITY(UI)=^%UTILITY($job,"ROUTINE")
 set %=^$job($job,"routine_vol"),VOL=^$s("vol",%,"name")
 set UCI=^$s("vol",%,"uci",^$job($job,"routine"))
 open 1:(FILE:"write") U 1 write "Saved by %ZRS(MODIFIED %RS) from ["_UCI_","_VOL_"] on "
 write $$D^%D($horolog)," at ",$$T^%T($piece($horolog,",",2)),!,HEAD,!
 set R="" for  set R=$order(^UTILITY(UI,R)) quit:R=""  do
 . use 0 write:$x>70 ! write R,?$x\10+1*10 use 1 write R,!
 . set %=0 for  set %=$order(^$routine(R,%)) quit:%=""  write ^$routine(R,%),!
 . write !
;---
EX write ! use 0 close 1 write !
 kill ^UTILITY(UI),^%UTILITY($job,"ROUTINE")
 quit

%ZRSE
%ZRSE ;WAA Routine search utility
 new STRING,LINE,CASE,LN,CNT
 set CNT=0
 do ^%ZRSEL
 if '$data(^%UTILITY($job,"ROUTINE")) goto EXIT
 read !,"Search for: ",STRING G:STRING="" EXIT
;---
CASE read !,"Case sensitive? (NO) :",CASE if CASE="" set CASE="NO"
 set X=CASE xecute ^%ZOSF("UPPERCASE")
 if '("YN"[$extract(CASE,1)) goto EXIT
 if $extract(CASE,1)="Y" set CASE=1
 if $extract(CASE,1)="N" set CASE=0,X=STRING xecute ^%ZOSF("UPPERCASE") set Y=STRING
 set ROUTINE=""
 for  set ROUTINE=$order(^%UTILITY($job,"ROUTINE",ROUTINE)) quit:ROUTINE=""  do
 . new LN
 . set LN=0
 . for  set LN=$order(^$routine(ROUTINE,LN)) quit:LN<1  do
 . . set LINE=^$routine(ROUTINE,LN)
 . . if 'CASE set X=LINE xecute ^%ZOSF("UPPERCASE") set LINE=Y
 . . if LINE[STRING write !,"    Routine: ",ROUTINE,"  LINE# ",LN,!,LINE set CNT=CNT+1
 . . quit
 . quit
 write !,CNT," Matches found."
 quit
;---
EXIT ;Clean up
 kill ^UTILITY($job,"ROUTINE")
 quit

%ZRSEL
%ZRSEL ;WAA-This routine is to select routines using wild cards 6/16/00
 ; General Utility version 1.0
 ;
 ; *=all routines
 ; nsp*=routinestarting with the listed namespace
 ; ^D(Up-arrow "D")= Display list of select routines
 ; ^L(Up-arrow "L")= Display list of all the routines in the current UCI
;---
;List of routines will be stored in the global ^%UTILITY($job,"ROUTINE")
EN1 ;Main Entry point
 new X,J
 kill ^%UTILITY($job,"ROUTINE")
;---
LOOP ;Main Read loop
 read !,"Select Routine(s): ",X quit:X=""
 if X="^D" do LIST goto LOOP
 if X="^L" do ^%RD goto LOOP
 set J=$extract(X,1) if J="-" set X=$extract(X,2,$length(X)),J=$extract(X,1) do DEL goto LOOP
 if X="*" do AWILD goto LOOP
 if $length(X)>$get(^$system("name_length"),8) write !,"NAME TOO LONG" goto LOOP
 if J'?1A,(J'?1"%") write !,"INVALID NAME" goto LOOP
 if X["*" do AWILD goto LOOP
 if '$data(^$routine(X)) write !,"INVALID ROUTINE NAME" goto LOOP
 set ^%UTILITY($job,"ROUTINE",X)=""
 goto LOOP
;---
DEL ;DELETE ROUTINE FROM LIST
 if X="*" kill ^%UTILITY($job,"ROUTINE") quit
 if X["*" set Y=$piece(X,"*") do
 . for  set Y=$order(^%UTILITY($job,"ROUTINE",Y)) quit:Y=""  quit:Y'[X  do
 . . kill ^%UTILITY($job,"ROUTINE",Y)
 . . quit
 . quit
 else  kill ^%UTILITY($job,"ROUTINE",X)
 quit
;---
AWILD ;SELECT ALL ROUTINES AS WILDCARDS
 new Y
 set Y=$piece(X,"*")
 for  set Y=$order(^$routine(Y)) quit:Y=""  quit:Y'[$piece(X,"*")  set ^%UTILITY($job,"ROUTINE",Y)=""
 quit
;---
LIST ;lIST SELECTED ROUTINES
 new Y
 set Y=""
 write !
 if '$data(^%UTILITY($job,"ROUTINE")) write !,"NO ROUTINES HAVE BEEN SELECTED" quit
 for  set Y=$order(^%UTILITY($job,"ROUTINE",Y)) quit:Y=""  do
 . write:$x>72 !
 . write Y,?($x+(10-($x#10)))
 . quit
 quit

%ZUCI
%ZUCI ;WAA-Change UCI;6/19/00
 ;ZUCI 1.0
 new X
EN1 ;Main Entry Point.
 read !,"What UCI: ",X
 if X="?" do LIST goto EN1
 do CD(X)
 write !,$$UCI
 quit
;---
CD(UCI) ;
 if 'UCI for %=1:1:64 if ^$s("vol",1,"uci",%)=UCI set UCI=% quit
 ;Make it into a number if possible
 goto CDE^%U:UCI<1!(UCI>64),CDE^%U:'$length(^$system("vol",1,"uci",UCI))
 ;Validate it
 for %="GLOBAL","LOCK","ROUTINE" set ^$job($job,%)=UCI
 ;Set all the bits
 quit
;---
LIST ;List all UCIs within a Volume set
 new VOL,UCI,X
 set VOL=1,UCI=""
 write !,"User Class Identifier's within the Volume set: ",^$system("vol",VOL,"name")
 write !,?10,"UCI#",?40,"UCI"
 write !,?10,"----",?40,"---"
 do GET(VOL,.UCI)
 for X=1:1:UCI write !,?10,X,?40,UCI(X)
 quit
;---
GET(VOL,UCI) ;Build an array if all the UCI with in the VOLUME Set.
 new X
 set UCI=0
 quit:VOL'>0  set X=0
 for  set X=$order(^$system("vol",VOL,"uci",X)) quit:X<1  set UCI=X,UCI(X)=^$system("vol",VOL,"uci",X)
 quit
;---
UCI() ;Return the current UCI and volume set
 new UCI,Y,VOL,JN,UCIN,VOLN
 set Y=""
 set JN=$job
 set UCI=^$job(JN,"routine"),VOL=^$job(JN,"routine_vol")
 set VOLN=^$system("vol",VOL,"name"),UCIN=^$system("vol",VOL,"uci",UCI)
 set Y=UCIN_","_VOLN
 quit Y

BENCH
BENCH ;From the DSM - BENCH ;V 2.9 28 Feb 99  01:27 PM
 write !!,"Use this utility to provide a benchmark test of CPU",!!
 goto A
;---
AAA quit
;---
A hang 1 set A=$piece($horolog,",",2)
 for I=1:1:1000000
 set A=$piece($horolog,",",2)-A,^FOR=A write A," seconds for: F I=1:1:1000000",!
;---
A1 set A=$piece($horolog,",",2)
 do SET for I=1:1:1000000 if $data(X)
 set A=$piece($horolog,",",2)-A,^OVR=A write A-^FOR," seconds for: I $D(X) ;X undefined",!!
;---
EVA write !!,"***COMMANDS AND EVALUATER***",!! set ^OVR=^FOR
 do SET for I=1:1:1000000 set X=""
 set A=$piece($horolog,",",2)-A,^SET=A write A-^OVR," seconds for: S X=""""",!
 do SET for I=1:1:1000000 set X=1
 do OUT write "S X=1",!
;---
EVB do SET for I=1:1:1000000 set X="ABCDEFGHIJ"
 do OUT write "S X=""ABCDEFGHIJ""",!
 do SET for I=1:1:1000000 set X="ABCDEFGHIJ01234567890123456789"
 do OUT write "S X=""ABCDEFGHIJ01234567890123456789""",!
 do SET for I=1:1:1000000 set X="^^"_"ABCD"_"^"_"ABCD"_"^"_"^"_"ABCD"
 do OUT write "S X=""^^""_""ABCD""_""^""_""ABCD""_""^""_""^""_""ABCD""",!
 set B=55 do SET for I=1:1:1000000 set X=B+33
 do OUT write "S X=B+33 ;B=55",!
 do SET for I=1:1:1000000 set X=B-1
 do OUT write "S X=B-1 ;B=55",!
 set B=55 do SET for I=1:1:1000000 if B>22
 do OUT write "I B>22 ;B=55",!
 set B="ABCDEFGHIJ" do SET for I=1:1:1000000 if B="ABCDEFGHIJ"
 do OUT write "I B=""ABCDEFGHIJ"" ;TRUE ",!
 do SET for I=1:1:1000000 if B["HIJ"
 do OUT write "I B[""HIJ"" ;TRUE ",!
;---
FUN write !!,"***FUNCTIONS***",! set ^OVR=^SET
 do SET for I=1:1:1000000 set X=$extract("ABCDEFGHIJ",9)
 do OUT write "$E(""ABCDEFGHIJ"",9)",!
 do SET for I=1:1:1000000 set X=$extract("ABCDEFGHIJ",9,10)
 do OUT write "$E(""ABCDEFGHIJ"",9,10)",!
 do SET for I=1:1:1000000 set X=$F("ABCDEFGHIJ","G",6)
 do OUT write "$F(""ABCDEFGHIJ"",""G"",6)",!
 do SET for I=1:1:1000000 set X=$length("ABCDEFGHIJ")
 do OUT write "$L(""ABCDEFGHIJ"")",!
 do SET for I=1:1:1000000 set X=$piece("A,B,C,D,E",",",3)
 do OUT write "$P(""A,B,C,D,E"","","",3)",!
 do SET for I=1:1:1000000 set X=$piece("A,B,C,D,E",",",3,5)
 do OUT write "$P(""A,B,C,D,E"","","",3,5)",!
;---
MIS write !!,"***MISCELLANEOUS TESTS***",!! set ^OVR=^FOR
 set B=55 do SET for I=1:1:1000000 set X=B*33
 do OUT write "S X=B*33 ;B=55",!
 do SET for I=1:1:1000000 set X=B\10
 do OUT write "S X=B\10 ;B=55",!
 do SET for I=1:1:1000000 set X=.5+.005
 do OUT write "S X=.5+.005",!
 do SET for I=1:1:1000000 do END
 do OUT write "D END ; END at bottom of routine",!
 do SET for I=1:1:1000000 do AAA
 do OUT write "D AAA ;AAA at beginning of routine",!
;---
END quit
;---
SET hang 1 set A=$piece($horolog,",",2) quit
;---
OUT write $piece($horolog,",",2)-A-^OVR," seconds for: " quit

COMPRESS
COMPRESS ;Compress a specific global on-line
 read !,"Compress which Global: ^",G,! quit:G=""
 write "Priority being lowered to 20 (the lowest)",! set ^$job($job,"priority")=20
 do INT(G) quit
;---
INT(G,%,LEV,ZR) new $etrap set ZR="INT^COMPRESS",$etrap="do ^%ET",LEV=12
 set G="^"_$translate(G,"^") if '$data(@G) write "Global ^",G," does not exist",! quit
 for  set LEV=$&%compress(G,LEV) quit:G["("  set LEV=LEV-1 quit:LEV<1
 if LEV>-1 write "Done",! quit
 set LEV="M"_-LEV  write *7,$&%errmsg(LEV),! quit

DECOMP
DECOMP ;Decompile an RSM routine
 new  read !,"Routine: ",ROU,! quit:ROU=""
 set C=$get(^$routine(ROU,0)) if C="" write "?No such routine as ",ROU,! quit
 write "Decompile of ",ROU,! do INT(C) quit
;---
INT(C,%,V,USR,D,T,H,TAG,VAR,I,S,A) new $etrap set $etrap="do ^%ET"
 new BIG,VARLEN set BIG=$$BIGEND^%U,VARLEN=$get(^$system("name_length"),8)
 set V=$$S(1) ;The compiler version
 set USR=$$S(3) ;The user
 set D=$$I(5),T=$$I(9) ;The Date and Time
 for %=1:1:6 set H(%)=$$S(%-1*2+13) ;Tag off, num; Var off, num; Code off, size
 write "Compiler version: ",V,"  User: ",USR,"  When: ",$$D^%D(D)," ",$$T^%T(T),!
 ;Load all tags into the TAG array
 for V=1:1:H(2) do
 . set T=V-1*(VARLEN+2)+H(1)+1 ;Offset to this tag
 . set D="" for %=0:1:(VARLEN-1) set I=$ascii(C,T+%) quit:'I  set D=D_$char(I) ;Extract the tag name
 . set TAG($$S(T+VARLEN))=D ;Save the tag indexed by address
 ;End of tag load code
 new COL,J set COL=10,J="" for  set J=$order(TAG(J)) quit:J=""  set COL=$select($length(TAG(J))+2>COL:$length(TAG(J))+2,1:COL)
 write !,"Tag",?COL,"Offset",!
 set %="" for  set %=$order(TAG(%)) quit:%=""  write TAG(%),?COL,$justify(%,6),!
 ;Load all variables
 for V=1:1:H(4) do
 . set T=V-1*VARLEN+H(3)+1 ;Offset to this variable
 . set D="" for %=0:1:(VARLEN-1) set I=$ascii(C,T+%) quit:'I  set D=D_$char(I) ;Extract the variable name
 . set VAR(V-1)=D ;Save var name indexed by idx
 write !,"Variables by Index",!
 set %="" for  set %=$order(VAR(%)) quit:%=""  write:$x>70 ! write VAR(%),?$x\10+1*10
 write:$x ! write !,"Code at offset ",H(5)," for ",H(6)," bytes.",!
 set V=H(5)+1,T=V+H(6),A=""
;---
LIN goto EXIT:V>T set D=$ascii(C,V),V=V+1 write ! if D=170 do
 . set I=$$S(V),S=$$S(V+2),V=V+4 set:S S=S-1
 . write "Line:",$justify(I,5),"   Size ",S,!,?6 if $length(A) write A,!,?6 set A=""
 . for %=1:1:S write:$x>75 !,?6 write $justify($ascii(C,V),4) set V=V+1
 if D=171 set A="Formal: (" set I=$ascii(C,V),V=V+1 do
 . if I=0 set A=A_")"
 . else  for %=1:1:I set A=A_VAR($ascii(C,V))_$select(I-%:",",1:")"),V=V+1
 if D=2 set I=$$S(V) write ?6,"Error: ",I
 goto LIN
;---
EXIT write ! quit
;---
S(O) ;Extract a u_short from C at offset O
 if $get(BIG,0) quit $ascii(C,O)*256+$ascii(C,O+1)
 else  quit $ascii(C,O+1)*256+$ascii(C,O)
;---
I(O,%,N) ;Extract a u_int from C at offset O
 set N=0
 if $get(BIG,0) for %=0:1:3 set N=N*256+$ascii(C,O+%)
 else  for %=3:-1:0 set N=N*256+$ascii(C,O+%)
 quit N

FBENCH
FBENCH ;DBB;12-JUN-81 1:25 AM;BENCHMARK REFERENCE STANDARD M
 kill  set K=1,T=1,T(0)=0,N=1000000 ;SET N TO MULTIPLE OF 500
 kill ^TSX write !,"Test #    Name      msec/Pass     Without for",!!
 for K=0:1:11 do DRV
 kill ^TSX kill  write !,*7,"Finished",! quit
;---
DRV ;
 write $justify(K,4),?7
 write $piece("For Loop^Do-Quit^String^Pattern^Function^Conversion^Integer^Real^Symbol Tbl^Glb Set^Glb Retrv^Composite","^",K+1)
 kill (K,N,T) if $text(@("A"_K))'="" do @("A"_K)
 hang 1 set T=$piece($horolog,",",2) do @K set T=$piece($horolog,",",2)-T set:'K T(0)=T/N
 set NN=$select(K<11:N,1:N\10) write ?20,$justify(T/NN*1000,8,2),?34,$justify(T/NN-T(0)*1000,8,2),! quit
;---
0 for J=1:1:N
 quit
;---
1 for J=1:1:N do A2,A2
 quit
;---
A2 set D="aaa/aaa,aaa,aaa" quit
;---
2 for J=1:1:N set I=$extract("abcdefghijklm",3,6)_$piece(D,",",2)["cdeg"
 quit
;---
A3 set C="abcd123XX" quit
;---
3 for J=1:1:N if C?1"abc".A3N.E,C?4E1"123"2U
 quit
;---
A4 set A=1,B=0,C=123.456 quit
;---
4 for J=1:1:N set I=$length($select($data(XXX):0,A:$justify(C,7,2),1:0))
 quit
;---
A5 set A=10,B=13 quit
;---
5 for J=1:1:N set I=A_B+A_B
 quit
;---
A6 set I=200 quit
;---
6 for J=1:1:N set I=I*I\I+I-I*25\25+25-25
 quit
;---
A7 set R=".222" quit
;---
7 for J=1:1:N set Y=R*R/R+R-R*.125/.125+.125-.125
 quit
;---
A8 set D=""
 for J=81:1:90 set D=D_"a" for I=71:1:90 set @($char(J,I)_"=D")
 kill I,J,D quit
;---
8 for J=1:1:N set A=J,A=TG,A=WQ,A=ZZ
 quit
;---
9 for J=1:1:N\500 for Y=1:1:20 set A=$extract(123456789,1,Y#10) for X=1:1:25 set ^TSX(Y,X)=A
 quit
;---
10 for J=1:1:N\500 for Y=1:1:20 for X=1:1:25 set C=^TSX(Y,X)
 quit
;---
11 for J=1:1:N\10 do B11
 quit
;---
B11 set A1=1,B1=A1+1,C1=B1_B1,D1=$extract(C1,3,99),E1="abcdefg"
 for I=2:1:5,8 set F(I)=$extract("123456789",1,I)
 kill:$length($data(F(3))) F(3) set L=I*22/3,E=$justify(L,6,2)
;---
B11B set L=$order(F(L)) G:L'="" B11B
 set A="aaa,",A=A_A_A_"xxxx" if A?3A1P.E set B=$piece(A,",",2,3)
 set:B["ppp" B=3 set C="d",@C=123
 kill A1,A,C1,C,F quit

FIX
FIX ;FIX Database ;V 3.1 20 May 2021 01:55 PM
 ;New a few things, setup error trap - Valid Volume always -1 for now
 new DTYP,D,K,BLK,CMD,LCMD,BSIZ,I,VV,$estack,$etrap set $etrap="do ERR^FIX",VV=-1
 new VARLEN,HDRSIZE,IDX,LONG set VARLEN=$get(^$system("name_length"),8),HDRSIZE=VARLEN+12,IDX=HDRSIZE/2
 set ^$system("vol",1,"writelock")=1 write !,"Writelocking the database"
 for  write "." quit:^$system("vol",1,"writelock")>0  hang 1
;---
;Get some input
ASK write:$x ! write "FIX> " read CMD,! set LCMD=CMD,CMD=$&e(CMD) set:CMD="" CMD="?"
 ;Check for a block number
 ;NOTE: If BLK ends in +, it will output the full data, not truncate it to 500
 if CMD?1.N.1"+" do  do BLK goto ASK
 . set BLK=CMD,LONG=0 set:$extract(BLK,$length(BLK))="+" LONG=$get(^$system("string_max"),32767),BLK=+BLK
 ;Look for Check
 if CMD="C" do  goto ASK
 . ;Ensure we have a block
 . if '$get(BLK) write "?No current block"_$char(7) quit
 . ;Do it
 . set %=$&%ic(-VV,BLK) write !,$select(%>1:%_" Errors",%:"1 Error",1:"No errors"),!
 ;Check for Dump
 if $extract(CMD)="D" do  write ! goto ASK
 . ;Enable writes
 . write "Write enabling disk... " set ^$system("vol",1,"writelock")=0
 . ;Do it
 . do INT^%BLKDMP(BLK_$select(LONG:"+",1:""),"^%DUMP") write "dumped to ^%DUMP()",!
 . set ^$system("vol",1,"writelock")=1 write "Writelocking the database"
 . for  write "." quit:^$system("vol",1,"writelock")>0  hang 1
 ;Check for Environment (UCI)
 if $extract(CMD)="E" do  goto ASK
 . ;Do it
 . for %=2:1:$length(CMD) if $extract(CMD,%)?1N set:+$extract(CMD,%,9)<64&$extract(CMD,%,9) D(0)=+$extract(CMD,%,9) quit
 ;Check for F or .
 if $extract(CMD)="F"!(CMD=".") do SAVE^FIX2 goto ASK
 ;Check for Global name change
 if $extract(CMD)="G" set LCMD=$extract(LCMD,2,99) do  goto ASK
 . ;Do it if OK
 . if VARLEN=32,LCMD?1"%"1.31AN!(LCMD?1A1.31AN) set K=LCMD quit
 . if VARLEN=8,LCMD?1"%"1.7AN!(LCMD?1A1.7AN) set K=LCMD quit
 . ;Complain
 . write "?Invalid global name '",LCMD,"'",$char(7),!
 ;Insert
 if $extract(CMD)="I" do INSERT^FIX1 goto ASK
 ;Check for KILL
 if $extract(CMD)="K" do  goto ASK
 . ;Get the index
 . set I=0 for %=2:1:$length(CMD) if $extract(CMD,%)?1N set I=+$extract(CMD,%,99) quit
 . ;Complain on error
 . if '$data(K(I)) write "?No such index as ",I,$char(7),! quit
 . ;Check for last
 . if '$order(K(I)) kill K(I)
 . ;Else shuffle down
 . else  for %=I:1 quit:'$data(K(%+1))  set K(%)=K(%+1),D(%)=D(%+1) kill K(%+1),D(%+1)
 . ;and say
 . write "Killed.",!
 ;Check for List
 if $extract(CMD)="L" do LIST goto ASK
 ;Check for a quit
 if $extract(CMD)="Q" view:$get(BLK) VV:0 set ^$system("vol",1,"writelock")=0 quit
 ;Check for RL change
 if $extract(CMD)="R" do  goto ASK
 . ;Store it here
 . for %=2:1:$length(CMD) if $extract(CMD,%)?1N set D=+$extract(CMD,%,99) quit
 ;Check for UP
 if $extract(CMD)="U" do UP^FIX2 goto ASK
 ;Check for Zot
 if $extract(CMD)="Z" do  goto ASK
 . ;Zot the block
 . set BSIZ=^$system("vol",1,"block") for I=0:4:BSIZ-1 set %=$view(VV,I,4,0)
 . ;Write it back
 . view VV:-BLK kill BLK
 ;Locate
 if $extract(CMD)="^" do LOCATE^FIX1 goto ASK
 ;Else give help
 do HELP^FIX2 goto ASK
;---
;Get the block and right link (if any)
BLK view VV:BLK set RL=$view(VV,4,4) if RL do
 . ;Get the block, addr of first record and size of same - adj for view
 . view VV:RL set R=$view(VV,HDRSIZE,2)*4,UCC=$view(VV,R+3,1),%=UCC set:%<3 %=3 set:%=4 %=5
 . ;Get the key into RL1
 . set RL1="^"_$piece($view(VV,12,VARLEN),$char(0))_"("_$$FULLUNK^FIX1($extract($view(VV,R+4,%),1,UCC))_")"
 . ;Re-get the original block
 . view VV:BLK
 ;Load the arrays
 do LOADA^FIX1
 write "Block Number: ",BLK,"  Type: ",$select('D(0):"Unused",K="$GLOBAL":"Global Directory",DTYP:"Data",1:"Pointer")
 if 'D(0) write ! quit
 write "  Last Index: ",$view(VV,8,2),"  Last Free: ",$view(VV,10,2),"  Free: ",$view(VV,10,2)*2-$view(VV,8,2)*2+2,!
 write ", UCI# ",$view(VV,0,1)#64," ["_^$system("vol",1,"uci",$view(VV,0,1)#64)_"]  Right -> ",RL,! set %=$order(K(""),-1)
 write "First Node: ^",K,$select($length($get(K(IDX))):"("_$$FULLUNK^FIX1(K(IDX))_")",1:""),!
 write:$get(%) "Last  Node: ^",K,"(",$$FULLUNK^FIX1(K(%)),")",!
 if RL write "Right Link: "_RL1,!
 quit
;---
;Check for a current block
LIST if '$get(BLK) write "?No current block",$char(7),! quit
 set SRCH=$extract(LCMD,2,999)
 write $select($length(SRCH):"Search ",1:"Listing of block "),BLK," (local copy) Global: ",K
 write:$length(SRCH) " [",SRCH,"]" write "  UCI# ",D(0)," ["_^$system("vol",1,"uci",D(0))_"]  Right: ",D,!
 write "Index Contains:",! for I=IDX:1 quit:'$data(K(I))  do
 . ;Get something we can display
 . set %=D(I) set:('LONG)&($length(%)>500) %=$extract(%,1,500)_"..." set:%?.E1C.E %=$$DISP^%U(%,LONG)
 . if $length(SRCH),%'[SRCH quit
 . write $justify(I,5)," ","(",$$FULLUNK^FIX1(K(I)),")=",% write:$data(DGD(I)) ?30,$justify(DGD(I),10) write !
 quit
;---
;Quit when done
ERR if $estack<2 set $ecode="" view:$get(BLK) VV:0 quit
 set ^$system("vol",1,"writelock")=0 write !,"**ERROR BEING LOGGED**",! goto ^%ET

FIX1
FIX1 ;FIX subroutine ;V 3.1 20 May 2021 01:55 PM
 quit
;---
;Load Arrays D and K and set DTYP from the current block
LOADA kill D,K,DGD new KEY,%,I,R,UCC,CCC,DBC set KEY=""
 ;Store global name in K and RL in D
 set K=$piece($view(VV,12,VARLEN),$char(0)),D=$view(VV,4,4),D(0)=$view(VV,0,1)#64
 ;Set DTYP true for a data block
 set DTYP=$view(VV,0,1)>64&(K'="$GLOBAL")
 ;Scan all indexes
 for I=IDX:1:$view(VV,8,2) do
 . ;Get the Record address, CCC and UCC
 . set R=$view(VV,I*2,2)*4,CCC=$view(VV,R+2,1),UCC=$view(VV,R+3,1)
 . ;Ensure we get a string return for the next $view()
 . set %=UCC,K(I)="" set:%=1!(%=2) %=3 set:%=4 %=5
 . ;If there is a key
 . if UCC do
 . . ;Copy uncommon key characters to the key buffer
 . . set $extract(KEY,CCC+1,CCC+UCC)=$extract($view(VV,R+4,%),1,UCC)
 . . ;Copy the key into the array
 . . set K(I)=$extract(KEY,1,CCC+UCC)
 . ;Point at data - If it's a data block
 . set R=R+UCC+4 if DTYP do
 . . ;Get the DBC, clear the data
 . . set DBC=$view(VV,R,2),D(I)=""
 . . ;Do it this way if it would have been an int
 . . if DBC<5 for %=1:1:DBC set D(I)=D(I)_$char($view(VV,R+1+%,1))
 . . ;This way to get a string
 . . else  set D(I)=$view(VV,R+2,DBC)
 . ;Else it's a pointer (or directory), round up (if reqd) and get blk#
 . else  set:R#4 R=R\4+1*4 set D(I)=$view(VV,R,4)
 . ;If Global directory get DGD
 . if K="$GLOBAL" set DGD(I)=$view(VV,R+4,4)
 quit
;---
;Locate a block
LOCATE new UCI,GLO,TB,IK,I set UCI=^$system("vol",1,"uci",1),LCMD=$extract(LCMD,2,999)
 ;Check for a specified UCI
 if $extract(LCMD)="[" set UCI=$piece($extract(LCMD,2,999),"]"),UCI=$translate(UCI,""""),LCMD=$piece(LCMD,"]",2,999)
 ;Setup the global and LCMD as the subscripts
 set GLO=$piece(LCMD,"("),LCMD=$piece(LCMD,"(",2,999),LCMD=$extract(LCMD,1,$length(LCMD)-1)
 ;Attempt to get the top block
 set TB=$get(^[UCI]$global(GLO))
 ;Complain if no such
 if 'TB write "?No such global as ^",GLO," in UCI: ",UCI,$char(7),! quit
 ;Make a key from it
 set IK=$$DOKEY(LCMD),BLK=TB
;---
;Get the block - done if it's data
LOC1 view VV:BLK do LOADA if DTYP goto BLK^FIX
 ;Look for it
 for I=IDX:1 quit:'$data(K(I))  if IK']K(I) quit
 ;Backup if required
 if $get(K(I))'=IK set I=I-1
 ;Loop again
 set BLK=D(I) goto LOC1
;---
;Remove the I from LCMD
INSERT new F,GLO,Q,%,S,I set LCMD=$extract(LCMD,2,999)
 ;Scan looking for the =
 set Q=0 for %=1:1:$length(LCMD)+1 do  quit:Q<0
 . ;Check for a quote
 . if $extract(LCMD,%)="""" set Q='Q quit
 . ;Check for the =
 . quit:Q  if $extract(LCMD,%)="=" set Q=-1
 ;Separate the source and destination
 set GLO=$extract(LCMD,1,%-1),LCMD=$extract(LCMD,%+1,999)
 ;Check for a block#
 if 'DTYP,LCMD'?1.N write "?Must specify a block# in a pointer block",$char(7) quit
 ;Remove any quotes
 if $extract(LCMD)="""" set @("LCMD="_LCMD)
 set:$extract(GLO)="^" GLO=$extract(GLO,2,99)
 ;Get subs into S
 set S=$piece(GLO,"(",2,999),GLO=$piece(GLO,"(")
 ;Check the global name (if any)
 if $length(GLO),GLO'=K write "?This block is ^",K," not ^",GLO,$char(7) quit
 ;Check for a trailing )
 if $extract(S,$length(S))'=")" write "?Junk subscript provided",$char(7) quit
 ;Get the KEY
 set S=$extract(S,1,$length(S)-1),S=$$DOKEY(S)
 ;Check if before first
 if S']K(IDX) write "WARNING: Specified key is before first key",!
 ;Look for insert point
 for I=IDX:1 quit:'$data(K(I))  if S']K(I) quit
 ;Check for end
 if '$data(K(I)) write "WARNING: Specified key is after last key",!
 ;See if it's already there
 else  if K(I)=S write "?That key exists",$char(7) quit
 ;Get last entry - copy down
 set F=$order(K(""),-1) for %=F:-1:I set K(%+1)=K(%),D(%+1)=D(%) set:$data(DGD(%)) DGD(%+1)=DGD(%)
 ;Store the new values and quit
 set K(I)=S,D(I)=LCMD write "Inserted." quit
;---
;Build a key for K - check for null then a string
BLDKEY(K) quit:K="" "" if +K'=K quit $char(128)_K_$char(0)
 ;Check 0 - then positive numbers
 quit:K=0 $char(64,0)  if K>0 quit $char($length($piece(K,"."))+64)_$translate(K,".")_$char(0)
 ;Finally the negative numbers
 quit $char(63-($length($piece(K,"."))-1))_$translate(K,"0123456789.-","9876543210")_$char(255)
;---
;Build a full key
DOKEY(K,%,Q,F) set F="" for  quit:K=""  do
 . ;Scan looking for first subscript
 . set Q=0 for %=1:1:$length(K)+1 do  quit:Q<0
 . . ;Check for a quote
 . . if $extract(K,%)="""" set Q='Q quit
 . . ;Check for a comma
 . . quit:Q  if $extract(K,%)="," set Q=-1
 . ;Get this subs into Q, rest into K - remove quotes if reqd
 . set Q=$extract(K,1,%-1),K=$extract(K,%+1,999) if $extract(Q)="""" set @("Q="_Q)
 . ;Add to the key
 . set F=F_$$BLDKEY(Q)
 ;Quit with the key
 quit F
;---
;Get string from key - check null
UNKEY(K,%,X,C) if $extract(K,1,2)=$char(0,0) set K=$extract(K,3,999) quit ""
 ;Special case for top node
 if K="" quit ""
 ;Check for a string
 if $ascii(K)=128 set %=$piece($extract(K,2,999),$char(0)),K=$piece(K,$char(0),2,999) quit %
 ;Get count - Remove terminator and trailing rubish from K, reset K
 set C=$ascii(K),X=$piece($piece($extract(K,2,999),$char(0)),$char(255)),K=$extract(K,$length(X)+3,999)
 ;Check for "0"
 if C=64&'X quit "0"
 ;If it's negative, do the complementing
 if C<64 set C=63-C,X=$translate(X,"0123456789","9876543210")
 ;Quit with the number
 quit $select(C<64:"-",1:"")_$extract(X,1,C#64)_$select($length(X)>(C#64):"."_$extract(X,C#64+1,999),1:"")
;---
;Do a full unkey
FULLUNK(K,A,%,F) set A="" for  set %=$$UNKEY(.K) do:+%'=%  set A=A_","_% quit:K=""
 . ;Simple (no embedded ")
 . if %'["""" set %=""""_%_"""" quit
 . ;Double the quotes
 . set F="""" for  quit:%=""  set F=F_$select($extract(%)="""":"""""",1:$extract(%)),%=$extract(%,2,999)
 . ;Terminate it
 . set %=F_""""
 quit $extract(A,2,999)

FIX2
FIX2 ;FIX subroutines ;V 3.1 20 May 2021 01:55 PM
 quit
;---
HELP ;Help menu
 write "Enter the number of the block to examine or one of:",!
 write ?8,"C to Check the current block and its descendants",!
 write ?8,"D to Dump the content of the current [data only] block to ^%DUMP()",!
 write ?8,"En to change the Environment (UCI) number for this block to n",!
 write ?8,"F or . to File (save) the current block",!
 write ?8,"Gname to change the Global name",!
 write ?8,"H or ? for Help",!
 write ?8,"I^node=value to Insert node with value or block number",!
 write ?8,"Kn to Kill (remove) index n",!
 write ?8,"L[search string] to List the local copy of the current block",!
 write ?8,"Q to Quit",!
 write ?8,"Rn to change the Right pointer to n",!
 write ?8,"U to go Up a level in the current global",!
 write ?8,"Z to Zot the block (mark unused) F or . are NOT required",!
 write ?8,"^spec to locate the block containing spec",!
 quit
;---
;Move up from current block
UP new KEY,GLO,TB,F,I,% set F=$view(VV,0,1)#64,F=^$system("vol",1,"uci",F)
 ;Save a few required values - get top of current global
 set KEY=K(IDX),GLO=K,TB=BLK,BLK=^[F]$global(GLO)
 ;If already at top, select the directory and use that
 if BLK=TB set BLK=^[F]$global("$GLOBAL") goto BLK^FIX
;---
;Get the data into the arrays
UP1 view VV:BLK do LOADA^FIX1
 ;Check that we got the correct one
 if K'=GLO write "?Found incorrect global in UP",$char(7),! goto BLK^FIX
 ;Ensure still a pointer
 if DTYP write "?Got back to data level in UP",$char(7),! goto BLK^FIX
 ;Look for it
 for I=IDX:1 quit:'$data(K(I))  if KEY']K(I) quit
 ;Backup if required
 if $get(K(I))'=KEY set I=I-1
 ;If there, exit
 if TB=D(I) goto BLK^FIX
 ;Loop again
 set BLK=D(I) goto UP1
;---
;Save current data
SAVE if '$get(BLK) write "?There is no current block",$char(7),! quit
 ;Get block size
 new BSIZ,CCC,UCC,I,R,%,F,CS,SZ set BSIZ=^$system("vol",1,"block"),SZ=0
 ;Loop thru all keys
 for I=IDX:1 quit:'$data(K(I))  do
 . ;Locate common character count
 . for CCC=0:1:$length($get(K(I-1))) quit:$extract($get(K(I-1)),CCC+1)'=$extract(K(I),CCC+1)
 . ;Get UCC and Chunk Size - round up if reqd
 . set UCC=$length(K(I))-CCC,CS=4+UCC+$select(DTYP:$length(D(I))+2,1:4) set:CS#4 CS=CS\4+1*4
 . ;Add required space
 . set SZ=SZ+CS+2
 ;Complain if it won't fit
 set SZ=(BSIZ-22)-SZ if SZ<0 write "?Doesn't fit by ",$translate(SZ,"-")," bytes",$char(7),! quit
 ;Zot the block (except first 4 bytes)
 for I=4:4:BSIZ-1 set %=$view(VV,I,4,0)
 ;Reset block type
 set %=$view(VV,0,1,K="$GLOBAL"!DTYP*64+D(0))
 ;Reset RL, last index, last free
 set %=$view(VV,4,4,D),%=$view(VV,8,2,IDX-1),%=$view(VV,10,2,BSIZ/4-1)
 ;Store the global name
 set I=K_$translate($justify("",VARLEN-$length(K))," ",$char(0)),%=$view(VV,12,VARLEN,I)
 ;Loop thru all keys
 for I=IDX:1 quit:'$data(K(I))  do
 . ;Locate common character count
 . for CCC=0:1:$length($get(K(I-1))) quit:$extract($get(K(I-1)),CCC+1)'=$extract(K(I),CCC+1)
 . ;Get UCC and Chunk Size - round up if reqd
 . set UCC=$length(K(I))-CCC,CS=4+UCC+$select(DTYP:$length(D(I))+2,1:4) set:CS#4 CS=CS\4+1*4
 . ;Allow for flags word
 . if K="$GLOBAL" set CS=CS+4
 . ;Set last free and this index - make R = address
 . set R=$view(VV,10,2)-(CS/4),%=$view(VV,10,2,R),R=R+1,%=$view(VV,I*2,2,R),R=R*4
 . ;and last index, setup chunk size, CCC and UCC
 . set %=$view(VV,8,2,I),%=$view(VV,R,2,CS),%=$view(VV,R+2,1,CCC),%=$view(VV,R+3,1,UCC)
 . ;Store it this way for a small size
 . if UCC<5 for F=1:1:UCC set %=$view(VV,R+3+F,1,$ascii(K(I),CCC+F))
 . ;or this way for a longer string
 . else  set %=$view(VV,R+4,UCC,$extract(K(I),CCC+1,CCC+UCC))
 . ;Point at the DBC
 . set R=R+UCC+4
 . ;For version 1.31 (or earlier), trim flags word
 . if K="$GLOBAL",$piece($system,"V",2)<1.32 set DGD(I)=DGD(I)#3
 . ;Do a pointer or Global Directory this way
 . if 'DTYP set:R#4 R=R\4+1*4 set %=$view(VV,R,4,D(I)) set:K="$GLOBAL" %=$view(VV,R+4,4,DGD(I)) quit
 . ;Store the length
 . set %=$view(VV,R,2,$length(D(I)))
 . ;Store it this way for a small size
 . if $length(D(I))<5 for F=1:1:$length(D(I)) set %=$view(VV,R+1+F,1,$ascii(D(I),F))
 . ;or this way for a longer string
 . else  set %=$view(VV,R+2,$length(D(I)),D(I))
 ;Do it and exit
 view VV:-BLK write "Filed.",! kill BLK quit

IC
IC ;Check Database
 new $etrap set $etrap="do ERR^IC"
 set ^$system("vol",1,"writelock")=1 write !,"Writelocking the database"
 for  write "." quit:^$system("vol",1,"writelock")>0  hang 1
 write !,"Checking Database",! set ER=$&%ic(1,0)
 write ! write:ER ER write $select(ER=0:"NO errors",ER>1:" errors",1:" error")," found.",!
;---
ERR set ^$system("vol",1,"writelock")=0 quit

JOURNLST
JOURNLST ;List journal file ;V 3.1 20 May 2021 01:55 PM
 new $etrap set $etrap="close 1 do ^%ET"
;---
ASK new FILE,ANS,DATA,ACTION,UCI,SIZE,NAME,TIME,EXT,OFF,OFFSET,MAGIC,VARLEN,TIMELEN,SLEN,KEY,REF,DBC,LONG
 set FILE=$get(^$system("vol",1,"journal_file")),LONG=0
 write "Enter file"_$select(FILE'="":" [<space><enter> for "_FILE_"]",1:"")_": "
 read ANS set:(ANS'=" ")&(ANS'="+") FILE=ANS write:(ANS=" ")!(ANS="+") FILE write ! set:ANS="+" FILE=FILE_ANS quit:FILE=""
 ;NOTE: If FILE ends in +, it will output the full data, not truncate it to 500
 if $extract(FILE,$length(FILE))="+" set LONG=$get(^$system("string_max"),32767),FILE=$extract(FILE,1,$length(FILE)-1)
 if '$&%file(FILE,"exists") write "NO SUCH FILE",! goto ASK
 close 1 open 1:(FILE:"read") use 1:("terminator=")
 read MAGIC#4,OFFSET#8 use 0
 set MAGIC=$$CVT(MAGIC),OFFSET=$$CVT(OFFSET)
 if MAGIC-4155766916 write "Invalid MAGIC number",! close 1 goto ASK
 set (VARLEN,TIMELEN)=8
 set OFF=12 use 1 read TIME#TIMELEN use 0 set SIZE=$$CVT($extract(TIME,1,2)),ACTION=$ascii(TIME,3),UCI=$ascii(TIME,4)
 ;Configure for new format journal, with 64 bit time_t and 32 character names
 if SIZE=12 set VARLEN=32,TIMELEN=12 use 1 read EXT#4 use 0 set TIME=TIME_EXT write !,"Reference Standard M Journal Version 2",!
 else  write !,"Reference Standard M Journal Version 1",!
 write "Date/Time",?24,"Action",?31,"UCI",?35,"Reference/Data",!
 ;Scan the file
 for  do  quit:OFF'<OFFSET
 . ;Get the fixed fields
 . if OFF>12 use 1 read TIME#TIMELEN use 0 set SIZE=$$CVT($extract(TIME,1,2)),ACTION=$ascii(TIME,3),UCI=$ascii(TIME,4)
 . ;Convert time
 . set TIME=$$CVT($extract(TIME,5,TIMELEN)),TIME=(TIME\86400+47117)_","_(TIME#86400)
 . ;Setup ACTION
 . set ACTION=$select(ACTION=5:"KILL",ACTION=4:"SET",ACTION=3:"ESTOP",ACTION=2:"STOP",ACTION=1:"START",'ACTION:"CREATE")
 . ;Write the first bit
 . write $$D^%D(+TIME)," ",$$T^%T($piece(TIME,",",2)),?24,ACTION write:UCI ?31,UCI
 . ;If a "small" one, that's all
 . if SIZE=TIMELEN set OFF=OFF+SIZE write ! quit
 . ;Get the rest of the record
 . set:SIZE#4 SIZE=SIZE\4+1*4 set OFF=OFF+SIZE use 1 read DATA#(SIZE-TIMELEN) use 0
 . ;Check for a 64 bit time_t here when listing an old format journal
 . if TIMELEN=8,$extract(DATA,1,4)=$char(0,0,0,0) set DATA=$extract(DATA,5,99999)
 . ;Extract the name and key length
 . set NAME=$translate($extract(DATA,1,VARLEN),$char(0)),SLEN=$ascii(DATA,VARLEN+1),DATA=$extract(DATA,VARLEN+2,99999)
 . ;Get the key
 . set KEY=$$FULLUNK^FIX1($extract(DATA,1,SLEN)),DATA=$extract(DATA,SLEN+1,99999)
 . ;Write the key - quit if not SET
 . set REF="^"_NAME_$select(SLEN:"("_KEY_")",1:"") write ?35,REF if ACTION'="SET" write ! quit
 . ;Extract the data
 . set DBC=$$CVT($extract(DATA,1,2)),DATA=$$DISP^%U($extract(DATA,3,DBC+2),LONG)
 . ;Finally the data (if any)
 . write "=",DATA,!
 close 1 quit
;---
CVT(BIN,I) ;Convert binary string to number
 set I=0
 if $$BIGEND^%U for  set I=I*256+$ascii(BIN),BIN=$extract(BIN,2,$length(BIN)) quit:'$length(BIN)
 else  for  set I=I*256+$ascii(BIN,$length(BIN)),BIN=$extract(BIN,1,$length(BIN)-1) quit:'$length(BIN)
 quit I

JOURNREC
JOURNREC ;Forward recover database from backup and journal file
 new $etrap set $etrap="close 1 do ^%ET"
;---
ASK new FILE,ANS,DATA,ACTION,UCI,SIZE,NAME,TIME,EXT,OFF,OFFSET,MAGIC,VARLEN,TIMELEN
 new SLEN,KEY,REF,DBC,LONG,QUIT,TYPE,START,END,FLG,VERBOSE,SETCNT,KILLCNT,EPOCH
 if ^$job>1 write "Journal recovery must be run in single-user mode",! quit
 set FILE=$get(^$system("vol",1,"journal_file")),LONG=0
 write "Enter file"_$select(FILE'="":" [<space><enter> for "_FILE_"]",1:"")_": "
 read ANS set:ANS'=" " FILE=ANS write:ANS=" " FILE write ! quit:FILE=""
 if '$&%file(FILE,"exists") write "NO SUCH FILE",! goto ASK
 close 1 open 1:(FILE:"read") use 1:("terminator=")
 read MAGIC#4,OFFSET#8 use 0
 set MAGIC=$$CVT^JOURNLST(MAGIC),OFFSET=$$CVT^JOURNLST(OFFSET)
 if MAGIC-4155766916 write "Invalid MAGIC number",! close 1 goto ASK
 set (VARLEN,TIMELEN)=8
 set OFF=12 use 1 read TIME#TIMELEN use 0 set SIZE=$$CVT^JOURNLST($extract(TIME,1,2)),ACTION=$ascii(TIME,3),UCI=$ascii(TIME,4)
 ;Configure for new format journal, with 64 bit time_t and 32 character names
 if SIZE=12 set VARLEN=32,TIMELEN=12 use 1 read EXT#4 use 0 set TIME=TIME_EXT write !,"Reference Standard M Journal Version 2",!!
 else  write !,"Reference Standard M Journal Version 1",!!
 write "Do you want to apply the entire journal "_FILE_" to "_^$system("vol",1,"name")_" ["_^$system("vol",1,"file")_"]? ([Y]/N): "
 read ANS write !
 set ANS=$translate(ANS,"yn","YN"),ANS=$extract(ANS)
 if ANS="N" set FLG=0 do
 . for  quit:FLG  do
 . . read "Enter start datetime for journal recovery: ",START set START=$&%spawn("date -ud '"_START_"' +""%s""",1) write !
 . . read "Enter end datetime for journal recovery: ",END set END=$&%spawn("date -ud '"_END_"' +""%s""",1) write !
 . . set START=$translate(START,$char(10,13)),END=$translate(END,$char(10,13))
 . . if START,END set FLG=1
 else  set START=0,END=999999999999
 read "Do you want to apply both sets and kills, only sets, or only kills? ([B]/S/K): ",TYPE write !
 set TYPE=$translate(TYPE,"bsk","BSK")
 read "Do you want verbose output of the journal recovery process? ([N]/Y): ",VERBOSE write !!
 set VERBOSE=$select($extract($translate(VERBOSE,"yn","YN"))="Y":1,1:0)
 set QUIT=0,TYPE=$select($extract(TYPE)="S":"SET",$extract(TYPE)="K":"KILL",1:"BOTH")
 if VERBOSE write "Date/Time",?24,"Action",?31,"UCI",?35,"Reference/Data",!
 set (SETCNT,KILLCNT)=0
 ;Scan the file
 for  do  quit:(OFF'<OFFSET)!QUIT
 . ;Get the fixed fields
 . if OFF>12 use 1 read TIME#TIMELEN use 0 set SIZE=$$CVT^JOURNLST($extract(TIME,1,2)),ACTION=$ascii(TIME,3),UCI=$ascii(TIME,4)
 . ;Convert time
 . set EPOCH=$$CVT^JOURNLST($extract(TIME,5,TIMELEN)),TIME=(EPOCH\86400+47117)_","_(EPOCH#86400)
 . ;Setup ACTION
 . set ACTION=$select(ACTION=5:"KILL",ACTION=4:"SET",ACTION=3:"ESTOP",ACTION=2:"STOP",ACTION=1:"START",'ACTION:"CREATE")
 . if (ACTION'="SET")&(ACTION'="KILL") set OFF=OFF+SIZE quit
 . ;Write the first bit
 . if VERBOSE,(EPOCH'>END)&(EPOCH'<START)&((TYPE=ACTION)!(TYPE="BOTH")) do
 . . write $$D^%D(+TIME)," ",$$T^%T($piece(TIME,",",2)),?24,ACTION write:UCI ?31,UCI
 . ;If a "small" one, that's all
 . if SIZE=TIMELEN set OFF=OFF+SIZE write:VERBOSE ! quit
 . ;Get the rest of the record
 . set:SIZE#4 SIZE=SIZE\4+1*4 set OFF=OFF+SIZE use 1 read DATA#(SIZE-TIMELEN) use 0
 . if (TYPE'=ACTION)&(TYPE'="BOTH") set OFF=OFF+SIZE quit
 . if EPOCH>END set QUIT=1 quit
 . if EPOCH<START quit
 . ;Check for a 64 bit time_t here when listing an old format journal
 . if TIMELEN=8,$extract(DATA,1,4)=$char(0,0,0,0) set DATA=$extract(DATA,5,99999)
 . ;Extract the name and key length
 . set NAME=$translate($extract(DATA,1,VARLEN),$char(0)),SLEN=$ascii(DATA,VARLEN+1),DATA=$extract(DATA,VARLEN+2,99999)
 . ;Get the key
 . set KEY=$$FULLUNK^FIX1($extract(DATA,1,SLEN)),DATA=$extract(DATA,SLEN+1,99999)
 . ;Write the key if verbose on - quit if not SET
 . set REF="^"_NAME_$select(SLEN:"("_KEY_")",1:"") write:VERBOSE ?35,REF if ACTION'="SET" write:VERBOSE !
 . ;Finally kill the data (if any)
 . if (ACTION="KILL")&((TYPE="KILL")!(TYPE="BOTH")) kill @REF set KILLCNT=$increment(KILLCNT) quit
 . ;Extract the data
 . set DBC=$$CVT^JOURNLST($extract(DATA,1,2)),DATA=$$DISP^%U($extract(DATA,3,DBC+2),LONG)
 . ;Finally set the data
 . set @REF=DATA,SETCNT=$increment(SETCNT)
 . ;Write the data (if verbose on)
 . if VERBOSE write "=",DATA,!
 write !,"Processed "_(SETCNT+KILLCNT)_" journal entries: "_SETCNT_" sets and "_KILLCNT_" kills",!
 close 1 quit

MATH
MATH ;
; Unless otherwise noted, the code below
; in ^MATH1 through ^MATH6 was approved
; in document X11/95-11
;
; If corrections have been applied,
; first the original line appears,
; with three semicolons at the beginning of the line.
;
; Then the source of the correction is acknowledged,
; then the corrected line appears, followed by a
; line containing three semicolons.
;
; MATH dispatch and polyfill routine
ABS(X)                  goto ABS^MATH1
ARCCOS(X)               goto ARCCOS^MATH1
ARCCOSX(X,PREC)         goto ARCCOSX^MATH1
ARCCOSH(X,PREC)         goto ARCCOSH^MATH1
ARCCOT(X,PREC)          goto ARCCOT^MATH1
ARCCOTH(X,PREC)         goto ARCCOTH^MATH1
ARCCSC(X,PREC)          goto ARCCSC^MATH1
ARCSEC(X,PREC)          goto ARCSEC^MATH1
ARCSIN(X)               goto ARCSIN^MATH1
ARCSINX(X,PREC)         goto ARCSINX^MATH1
ARCSINH(X,PREC)         goto ARCSINH^MATH1
ARCTAN(X,PREC)          goto ARCTAN^MATH1
ARCTANH(X,PREC)         goto ARCTANH^MATH1
CABS(Z)                 goto CABS^MATH2
CADD(X,Y)               goto CADD^MATH2
CCOS(Z,PREC)            goto CCOS^MATH2
CDIV(X,Y)               goto CDIV^MATH2
CEXP(Z,PREC)            goto CEXP^MATH2
CLOG(Z,PREC)            goto CLOG^MATH2
CMUL(X,Y)               goto CMUL^MATH2
COMPLEX(X)              goto COMPLEX^MATH2
CONJUG(Z)               goto CONJUG^MATH2
COS(X)                  goto COS^MATH2
COSX(X,PREC)            goto COSX^MATH2
COSH(X,PREC)            goto COSH^MATH2
COT(X,PREC)             goto COT^MATH2
COTH(X,PREC)            goto COTH^MATH2
CPOWER(Z,N,PREC)        goto CPOWER^MATH2
CSC(X,PREC)             goto CSC^MATH2
CSCH(X,PREC)            goto CSCH^MATH2
CSIN(Z,PREC)            goto CSIN^MATH2
CSUB(X,Y)               goto CSUB^MATH2
DECDMS(X,PREC)          goto DECDMS^MATH2
DEGRAD(X)               goto DEGRAD^MATH2
DMSDEC(X)               goto DMSDEC^MATH2
E()                     goto E^MATH3
EXP(X,PREC)             goto EXP^MATH3
LOG(X,PREC)             goto LOG^MATH3
LOG10(X,PREC)           goto LOG10^MATH3
MTXADD(A,B,R,ROWS,COLS) goto MTXADD^MATH3
MTXCOF(A,I,K,N)         goto MTXCOF^MATH3
MTXCOPY(A,R,ROWS,COLS)  goto MTXCOPY^MATH3
MTXDET(A,N)             goto MTXDET^MATH3
MTXEQU(A,B,R,N,M)       goto MTXEQU^MATH3
MTXINV(A,R,N)           goto MTXINV^MATH3
MTXMUL(A,B,R,M,L,N)     goto MTXMUL^MATH3
MTXSCA(A,R,ROWS,COLS,S) goto MTXSCA^MATH3
MTXSUB(A,B,R,ROWS,COLS) goto MTXSUB^MATH3
MTXTRP(A,R,M,N)         goto MTXTRP^MATH3
MTXUNIT(R,N,SPARSE)     goto MTXUNIT^MATH3
PI()                    goto PI^MATH4
PRODUCE(IN,SPEC,MAX)    goto PRODUCE^MATH4
RADDEG(X)               goto RADDEG^MATH4
REPLACE(IN,SPEC)        goto REPLACE^MATH4
SEC(X,PREC)             goto SEC^MATH4
SECH(X,PREC)            goto SECH^MATH4
SIGN(X)                 goto SIGN^MATH4
SIN(X)                  goto SIN^MATH4
SINX(X,PREC)            goto SINX^MATH4
SINH(X,PREC)            goto SINH^MATH4
SQRT(X,PREC)            goto SQRT^MATH4
TAN(X,PREC)             goto TAN^MATH5
TANH(X,PREC)            goto TANH^MATH5
FORMAT(V,S)             goto FORMAT^MATH5
XOR(a,b,w)              goto XOR^MATH6
CRC16(string,seed)      goto CRC16^MATH6
CRC32(string,seed)      goto CRC32^MATH6
CRCCCITT(string,seed)   goto CRCCCITT^MATH6
LOWER(A,CHARMOD)        goto LOWER^MATH6
PATCODE(A,PAT,CHARMOD)  goto PATCODE^MATH6
UPPER(A,CHARMOD)        goto UPPER^MATH6
;---
KVALUE(R,ROW,COL) ;KVALUE polyfill
 new TMP,I,J merge TMP=R kill R
 for I=1:1:ROW for J=1:1:COL if '((I=ROW)&(J=COL)) set R(I,J)=TMP(I,J)
 quit

MATH1
MATH1 ;
;---
ABS quit $translate(+X,"-")
;---
ARCCOS ;
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: This version of the function is
 ;          optimized for speed, not for precision.
 ;          The 'precision' parameter is not supported,
 ;          and the precision is at best 2 in 10**-8.
 ;;;
 new A,N,R,SIGN,XX
 if X<-1 set $ecode=",M28,"
 if X>1  set $ecode=",M28,"
 set SIGN=1 set:X<0 X=-X,SIGN=-1
 set A(0)=1.5707963050,A(1)=-0.2145988016,A(2)=0.0889789874
 set A(3)=-0.0501743046,A(4)=0.0308918810,A(5)=-0.0170881256
 set A(6)=0.0066700901,A(7)=-0.0012624911
 set R=A(0),XX=1 for N=1:1:7 set XX=XX*X,R=A(N)*XX+R
 ;;; set R=$$SQRT^MATH(1-X)*R ; Number ~~
 ; Winfried Gerum (8 June 1995)
 set R=$$SQRT^MATH(1-X,11)*R
 ;;;
 quit R*SIGN
;---
ARCCOSX ;
 ;;; New L,LIM,K,SIG,SIGS ; Number ~~
 ; Winfried Gerum (8 June 1995)
 new L,LIM,K,SIG,SIGS,VALUE
 ;;;
 if X<-1 set $ecode=",M28,"
 if X>1 set $ecode=",M28,"
 set PREC=$get(PREC,11)
 ;;; if $translate(X,"-")=1 set VALUE=0 quit ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 if $translate(X,"-")=1 quit 0
 ;;;
 set SIG=$select(X<0:-1,1:1),VALUE=1-(X*X)
 ;;; set X=$$SQRT^MATH(VALUE) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 set X=$$SQRT^MATH(VALUE,PREC)
 ;;;
 ;;; if $translate(X,"-")=1 do  quit ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 if $translate(X,"-")=1 do  quit VALUE
 . set VALUE=$$PI^MATH()/2*X
 . quit
 ;;; if X>0.9 do  quit ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 if X>0.9 do  quit VALUE
 . set SIGS=$select(X<0:-1,1:1)
 . set VALUE=1/(1/X/X-1)
 . ;;; set X=$$SQRT^MATH(VALUE) ; Number ~~
 . ; Winfried Gerum (8 June 1995)
 . set X=$$SQRT^MATH(VALUE,PREC)
 . ;;; set VALUE=$$ARCTAN^MATH(X,10)*SIGS ; Number ~~
 . ; Winfried Gerum (8 June 1995)
 . set VALUE=$$ARCTAN^MATH(X,PREC)*SIGS
 set (VALUE,L)=X
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(L,"-")<LIM)
 . set L=L*X*X*(K-2)/(K-1)*(K-2)/K,VALUE=VALUE+L
 . quit
 quit $select(SIG<0:$$PI^MATH()-VALUE,1:VALUE)
;---
ARCCOSH ;
 if X<1 set $ecode=",M28,"
 new SQ
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set SQ=$$SQRT^MATH(X*X-1,PREC)
 quit $$LOG^MATH(X+SQ,PREC)
;---
ARCCOT ;
 set PREC=$get(PREC,11)
 set X=1/X
 quit $$ARCTAN^MATH(X,PREC)
;---
ARCCOTH ;
 new L1,L2
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set L1=$$LOG^MATH(X+1,PREC)
 set L2=$$LOG^MATH(X-1,PREC)
 quit L1-L2/2
;---
ARCCSC ;
 set PREC=$get(PREC,11)
 set X=1/X
 quit $$ARCSINX^MATH(X,PREC)
;---
ARCSEC ;
 set PREC=$get(PREC,11)
 set X=1/X
 quit $$ARCCOSX^MATH(X,PREC)
;---
ARCSIN ;
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: This version of the function is
 ;          optimized for speed, not for precision.
 ;          The 'precision' parameter is not supported,
 ;          and the precision is at best 2 in 10**-8.
 ;;;
 new A,N,R,SIGN,XX
 if X<-1 set $ecode=",M28,"
 if X>1  set $ecode=",M28,"
 set SIGN=1 set:X<0 X=-X,SIGN=-1
 set A(0)=1.5707963050,A(1)=-0.2145988016,A(2)=0.0889789874
 set A(3)=-0.0501743046,A(4)=0.0308918810,A(5)=-0.0170881256
 set A(6)=0.0066700901,A(7)=-0.0012624911
 set R=A(0),XX=1 for N=1:1:7 set XX=XX*X,R=A(N)*XX+R
 ;;; set R=$$SQRT^MATH(1-X)*R ; Number ~~
 ; Winfried Gerum (8 June 1995)
 set R=$$SQRT^MATH(1-X,11)*R
 ;;;
 set R=$$PI^MATH()/2-R
 quit R*SIGN
;---
ARCSINX ;
 new L,LIM,K,SIGS,VALUE
 set PREC=$get(PREC,11)
 ;;; if $translate(X,"-")=1 do  quit ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 if $translate(X,"-")=1 do  quit VALUE
 . set VALUE=$$PI^MATH()/2*X
 ;;; if X>0.99999 do  quit ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 if X>0.99999 do  quit VALUE
 . set SIGS=$select(X<0:-1,1:1)
 . set VALUE=1/(1/X/X-1)
 . ;;; set X=$$SQRT^MATH(VALUE) ; Number ~~
 . ; Winfried Gerum (8 June 1995)
 . set X=$$SQRT^MATH(VALUE,PREC)
 . ;;; set VALUE=$$ARCTAN^MATH(X,10)*SIGS ; Number ~~
 . ; Winfried Gerum (8 June 1995)
 . set VALUE=$$ARCTAN^MATH(X,PREC)*SIGS
 set (VALUE,L)=X
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(L,"-")<LIM)
 . set L=L*X*X*(K-2)/(K-1)*(K-2)/K,VALUE=VALUE+L
 . quit
 quit VALUE
;---
ARCSINH ;
 if X<1 set $ecode=",M28,"
 new SQ
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set SQ=$$SQRT^MATH(X*X+1,PREC)
 quit $$LOG^MATH(X+SQ,PREC)
;---
ARCTAN ;
 new FOLD,HI,L,LIM,LO,K,SIGN,SIGS,SIGT,VALUE
 set PREC=$get(PREC,11)
 set LO=0.0000000001,HI=9999999999
 set SIGT=$select(X<0:-1,1:1),X=$translate(X,"-")
 set X=$select(X<LO:LO,X>HI:HI,1:X)
 ;;; set FOLD=$select(X'<1:0,1:1), ; Number ~~
 ; Eli Reidler (28 June 1996)
 set FOLD=$select(X'<1:0,1:1)
 ;;;
 set X=$select(FOLD:1/X,1:X)
 set L=X,VALUE=$$PI^MATH()/2-(1/X),SIGN=1
 ;;; if X<1.3 do  quit ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 if X<1.3 do  quit VALUE
 . set X=$select(FOLD:1/X,1:X),VALUE=1/((1/X/X)+1)
 . ;;; set $$SQRT^MATH(VALUE) ; Number ~~
 . ; Winfried Gerum (8 June 1995)
 . ; Eli Reidler (28 June 1996)
 . set X=$$SQRT^MATH(VALUE,PREC)
 . if $translate(X,"-")=1 do  quit
 . . set VALUE=$$PI^MATH()/2*X
 . . quit
 . if X>0.9 do  quit
 . . set SIGS=$select(X<0:-1,1:1)
 . . set VALUE=1/(1/X/X-1)
 . . set X=$$SQRT^MATH(VALUE)
 . . set VALUE=$$ARCTAN(X,10)
 . . set VALUE=VALUE*SIGS
 . . quit
 . set (VALUE,L)=X
 . set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 . for K=3:2 do  quit:($translate(L,"-")<LIM)
 . . set L=L*X*X*(K-2)/(K-1)*(K-2)/K,VALUE=VALUE+L
 . . quit
 . set VALUE=$select(SIGT<1:-VALUE,1:VALUE)
 . quit
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(1/L,"-")<LIM)
 . ;;; set L=L*X*X,VALUE=VALUE+(1/(K*L)*SIGN), ; Number ~~
 . ; Eli Reidler (28 June 1996)
 . set L=L*X*X,VALUE=VALUE+(1/(K*L)*SIGN)
 . set SIGN=SIGN*-1
 . quit
 set VALUE=$select(FOLD:$$PI^MATH()/2-VALUE,1:VALUE)
 set VALUE=$select(SIGT<1:-VALUE,1:VALUE)
 quit VALUE
;---
ARCTANH ;
 if X<-1 set $ecode=",M28,"
 if X>1  set $ecode=",M28,"
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 quit $$LOG^MATH(1+X/(1-X),PREC)/2

MATH2
MATH2 ;
;---
CABS ;
 new ZRE,ZIM
 set ZRE=+Z,ZIM=+$piece(Z,"%",2)
 quit $$SQRT^MATH(ZRE*ZRE+(ZIM*ZIM))
;---
CADD ;
 new XRE,XIM,YRE,YIM
 set XRE=+X,XIM=+$piece(X,"%",2)
 set YRE=+Y,YIM=+$piece(Y,"%",2)
 quit XRE+YRE_"%"_(XIM+YIM)
;---
CCOS ;
 new E1,E2,IA
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set IA=$$CMUL^MATH(Z,"0%1")
 set E1=$$CEXP^MATH(IA,PREC)
 set IA=-IA_"%"_(-$piece(IA,"%",2))
 set E2=$$CEXP^MATH(IA,PREC)
 set IA=$$CADD^MATH(E1,E2)
 quit $$CMUL^MATH(IA,"0.5%0")
;---
CDIV ;
 new D,IM,RE,XIM,XRE,YIM,YRE
 set XRE=+X,XIM=+$piece(X,"%",2)
 set YRE=+Y,YIM=+$piece(Y,"%",2)
 set D=YRE*YRE+(YIM*YIM)
 set RE=XRE*YRE+(XIM*YIM)/D
 set IM=XIM*YRE-(XRE*YIM)/D
 quit RE_"%"_IM
;---
CEXP ;
 new R,ZIM,ZRE
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set ZRE=+Z,ZIM=+$piece(Z,"%",2)
 set R=$$EXP^MATH(ZRE,PREC)
 quit R*$$COSX^MATH(ZIM,PREC)_"%"_(R*$$SINX^MATH(ZIM,PREC))
;---
CLOG ;
 new ABS,ARG,ZIM,ZRE
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set ABS=$$CABS^MATH(Z)
 set ZRE=+Z,ZIM=+$piece(Z,"%",2)
 ;;; set ARG=$$ARCTAN^MATH(ZIM,ZRE,PREC) ; Number ~~
 ; Alan Frank (October 1995)
 set ARG=$$ARCTAN^MATH(ZIM/ZRE,PREC)
 ;;;
 quit $$LOG^MATH(ABS,PREC)_"%"_ARG
;---
CMUL ;
 new XIM,XRE,YIM,YRE
 set XRE=+X,XIM=+$piece(X,"%",2)
 set YRE=+Y,YIM=+$piece(Y,"%",2)
 quit XRE*YRE-(XIM*YIM)_"%"_(XRE*YIM+(XIM*YRE))
;---
COMPLEX quit +X_"%0"
;---
CONJUG ;
 new ZIM,ZRE
 set ZRE=+Z,ZIM=+$piece(Z,"%",2)
 quit ZRE_"%"_(-ZIM)
;---
COS ;
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: This version of the function is
 ;          optimized for speed, not for precision.
 ;          The 'precision' parameter is not supported,
 ;          and the precision is at best 1 in 10**-9.
 ;          Note that this function does not accept its
 ;          parameter in degrees, minutes and seconds.
 ;;;
 new A,N,PI,R,SIGN,XX
 ; This approximation only works for 0 <= x <= pi/2
 ; so reduce angle to correct quadrant.
 set PI=$$PI^MATH(),X=X#(PI*2),SIGN=1
 set:X>PI X=2*PI-X
 set:X*2>PI X=PI-X,SIGN=-1
 set XX=X*X,A(1)=-0.4999999963,A(2)=0.0416666418
 set A(3)=-0.0013888397,A(4)=0.0000247609,A(5)=-0.0000002605
 set (X,R)=1 for N=1:1:5 set X=X*XX,R=A(N)*X+R
 quit R*SIGN
;---
COSX ;
 new L,LIM,K,SIGN,VALUE
 ;;; set:X[":" X=$$DMSDEC^MATH(X,12) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: The official description does not mention than
 ;          the function may also be called with the first
 ;          parameter in degrees, minutes and seconds.
 set:X[":" X=$$DMSDEC^MATH(X)
 ;;;
 set PREC=$get(PREC,11)
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=1,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=2:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L*X*X/(K-1*K),VALUE=VALUE+(SIGN*L)
 . quit
 quit VALUE
;---
COSH ;
 ;;; New F,I,P,R,T,XX ; Number ~~
 ; Winfried Gerum (8 June 1995)
 new E,F,I,P,R,T,XX
 ;;;
 set PREC=$get(PREC,11)+1
 set @("E=1E-"_PREC)
 set XX=X*X,F=1,(P,R,T)=1,I=1
 for  set T=T*XX,F=I+1*I*F,R=T/F+R,P=P-R/R,I=I+2 if -E<P,P<E quit
 quit R
;---
COT ;
 new C,L,LIM,K,SIGN,VALUE
 ;;; set:X[":" X=$$DMSDEC^MATH(X,12) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: The official description does not mention than
 ;          the function may also be called with the first
 ;          parameter in degrees, minutes and seconds.
 set:X[":" X=$$DMSDEC^MATH(X)
 ;;;
 set PREC=$get(PREC,11)
 set (VALUE,L)=1,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=2:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L*X*X/(K-1*K),VALUE=VALUE+(SIGN*L)
 . quit
 set C=VALUE
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=X,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L/(K-1)*X/K*X,VALUE=VALUE+(SIGN*L)
 . quit
 if 'VALUE quit "INFINITE"
 quit VALUE=C/VALUE
;---
COTH ;
 new SINH
 if 'X quit "INFINITE"
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set SINH=$$SINH^MATH(X,PREC)
 if 'SINH quit "INFINITE"
 quit $$COSH^MATH(X,PREC)/SINH
;---
CPOWER ;
 new AR,NIM,NRE,PHI,PI,R,RHO,TH,ZIM,ZRE
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set ZRE=+Z,ZIM=+$piece(Z,"%",2)
 set NRE=+N,NIM=+$piece(N,"%",2)
 if 'ZRE,'ZIM,'NRE,'NIM set $ecode=",M28,"
 ;;; if 'ZRE,'ZIM quit "0%0% ; Number ~~
 ; Eli Reidler (28 June 1996)
 if 'ZRE,'ZIM quit "0%0"
 ;;;
 set PI=$$PI^MATH()
 ;;; set R=$$SQRT^MATH(ZRE*ZRE+(ZIM*ZIM,PREC)) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 set R=$$SQRT^MATH(ZRE*ZRE+(ZIM*ZIM),PREC)
 ;;;
 ;;; if ZRE set TH=$$ARCTAN^MATH(ZIM,ZRE,PREC) ; Number ~~
 ; Alan Frank (October 1995)
 if ZRE set TH=$$ARCTAN^MATH(ZIM/ZRE,PREC)
 ;;;
 ;;; else  set TH=$select(ZRE>0:PI/2,1:-PI/2) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 else  set TH=$select(ZIM>0:PI/2,1:-PI/2)
 ;;;
 set RHO=$$LOG^MATH(R,PREC)
 set AR=$$EXP^MATH(RHO*NRE-(TH*NIM),PREC)
 set PHI=RHO*NIM+(NRE*TH)
 quit AR*$$COSX^MATH(PHI,PREC)_"%"_(AR*$$SINX^MATH(PHI,PREC))
;---
CSC ;
 new L,LIM,K,SIGN,VALUE
 ;;; set:X[":" X=$$DMSDEC^MATH(X,12) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: The official description does not mention than
 ;          the function may also be called with the first
 ;          parameter in degrees, minutes and seconds.
 set:X[":" X=$$DMSDEC^MATH(X)
 ;;;
 ;;; set PREC=$select($data(PREC)#2:PREC,1:10) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 set PREC=$get(PREC,11)
 ;;;
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=X,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L/(K-1)*X/K*X,VALUE=VALUE+(SIGN*L)
 . quit
 if 'VALUE quit "INFINITE"
 quit 1/VALUE
;---
CSCH ;;; quit 1/$$SINH^MATH(X,PREC) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 quit 1/$$SINH^MATH(X,$get(PREC,11))
 ;;;
;---
CSIN ;
 new IA,E1,E2
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 set IA=$$CMUL^MATH(Z,"0%1")
 set E1=$$CEXP^MATH(IA,PREC)
 set IA=-IA_"%"_(-$piece(IA,"%",2))
 set E2=$$CEXP^MATH(IA,PREC)
 set IA=$$CSUB^MATH(E1,E2)
 set IA=$$CMUL^MATH(IA,"0.5%0")
 quit $$CMUL^MATH("0%-1",IA)
;---
CSUB ;
 new XIM,XRE,YIM,YRE
 set XRE=+X,XIM=+$piece(X,"%",2)
 set YRE=+Y,YIM=+$piece(Y,"%",2)
 quit XRE-YRE_"%"_(XIM-YIM)
;---
DECDMS ;
 set PREC=$get(PREC,5)
 set X=X#360*3600
 set X=+$justify(X,0,$select((PREC-$length(X\1))'<0:PREC-$length(X\1),1:0))
 quit X\3600_":"_(X\60#60)_":"_(X#60)
;---
DEGRAD quit X*$$PI^MATH()/180
;---
DMSDEC ;
 quit $piece(X,":")+($piece(X,":",2)/60)+($piece(X,":",3)/3600)

MATH3
MATH3 ;
;---
E new prec,e
 set prec=^$job($job,"precision")
 set e=2+$extract(.7182818284590452353602874713526624977572470936999595749669676277,1,prec+2)
 if prec=0 quit 2
 if prec=64 quit e
 quit $extract(e,1,$length(e)-2)_($extract(e,$length(e)-1)+$select($extract(e,$length(e))>4:1,1:0))
;---
EXP ;
 new L,LIM,K,VALUE
 set PREC=$get(PREC,11)
 set L=X,VALUE=X+1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=2:1 set L=L*X/K,VALUE=VALUE+L quit:($translate(L,"-")<LIM)
 quit VALUE
;---
LOG ;
 new L,LIM,M,N,K,VALUE
 if X'>0 set $ecode=",M28,"
 set PREC=$get(PREC,11)
 set M=1
 ;;; if X>0 for N=0:1 quit:(X/M)<10  set M=M*10 ; Number ~~
 ; Winfried Gerum (8 June 1995)
 for N=0:1 quit:(X/M)<10  set M=M*10
 ;;;
 if X<1 for N=0:-1 quit:(X/M)>0.1  set M=M*0.1
 set X=X/M
 set X=(X-1)/(X+1),(VALUE,L)=X
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 set L=L*X*X,M=L/K,VALUE=M+VALUE set:M<0 M=-M quit:M<LIM
;DLW - log10: E**2.3025850929940456840179914546843642076011014886287729760333279009=10
 set VALUE=VALUE*2+(N*2.30258509298749)
 quit VALUE
;---
LOG10 ;
 new L,LIM,M,N,K,VALUE
 if X'>0 set $ecode=",M28,"
 set PREC=$get(PREC,11)
 set M=1
 ;;; if X>0 for N=0:1 quit:(X/M)<10  set M=M*10 ; Number ~~
 ; Winfried Gerum (8 June 1995)
 for N=0:1 quit:(X/M)<10  set M=M*10
 ;;;
 if X<1 for N=0:-1 quit:(X/M)>0.1  set M=M*0.1
 set X=X/M
 set X=(X-1)/(X+1),(VALUE,L)=X
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 set L=L*X*X,M=L/K,VALUE=M+VALUE set:M<0 M=-M quit:M<LIM
 set VALUE=VALUE*2+(N*2.30258509298749)
 quit VALUE/2.30258509298749
;---
MTXADD ;
 ;Add A[ROWS,COLS] to B[ROWS,COLS], result goes to R[ROWS,COLS]
 if $data(A)<10  quit 0
 if $data(B)<10  quit 0
 if $get(ROWS)<1 quit 0
 if $get(COLS)<1 quit 0
 new ROW,COL,ANY
 for ROW=1:1:ROWS for COL=1:1:COLS do
 . do KVALUE^MATH(.R,ROW,COL) set ANY=0
 . set:$data(A(ROW,COL))#2 ANY=1
 . set:$data(B(ROW,COL))#2 ANY=1
 . set:ANY R(ROW,COL)=$get(A(ROW,COL))+$get(B(ROW,COL))
 . quit
 quit 1
;---
MTXCOF ;
 ;Compute cofactor for element [i,k] in matrix A[N,N]
 new T,R,C,RR,CC
 set CC=0 for C=1:1:N do:C'=K
 . set CC=CC+1,RR=0
 . for R=1:1:N set:R'=I RR=RR+1,T(RR,CC)=$get(A(R,C))
 . quit
 quit $$MTXDET^MATH(.T,N-1)
;---
MTXCOPY ;
 ;Copy A[ROWS,COLS] to R[ROWS,COLS]
 if $data(A)<10  quit 0
 if $get(ROWS)<1 quit 0
 if $get(COLS)<1 quit 0
 new ROW,COL
 for ROW=1:1:ROWS for COL=1:1:COLS do
 . do KVALUE^MATH(.R,ROW,COL)
 . set:$data(A(ROW,COL))#2 R(ROW,COL)=A(ROW,COL)
 . quit
 quit 1
;---
MTXDET ;
 ;Compute determinant of matrix A[N,N]
 if $data(A)<10 quit ""
 if $get(N)<1   quit ""
 ;First the simple cases
 if N=1 quit $get(A(1,1))
 if N=2 quit $get(A(1,1))*$get(A(2,2))-($get(A(1,2))*$get(A(2,1)))
 new DET,I,SIGN
 ;Det A = sum (k=1:n) element (i,k) * cofactor [i,k]
 set DET=0,SIGN=1
 for I=1:1:N do
 . set DET=$get(A(1,I))*$$MTXCOF^MATH(.A,1,I,N)*SIGN+DET
 . set SIGN=-SIGN
 . quit
 quit DET
;---
MTXEQU ;
 ;Solve matrix equation A [M,M] * R [M,N] = B [M,N]
 if $get(M)<1 quit ""
 if $get(N)<1 quit ""
 ;;; if '$$MTXDET^MATH(.A) quit 0
 ; Ed de Moel, 29 August 1999
 if '$$MTXDET^MATH(.A,M) quit 0
 ;;;
 new I,I1,J,J1,J2,K,L,T,T1,T2,TEMP,X
 set X=$$MTXCOPY^MATH(.A,.T,N,N)
 set X=$$MTXCOPY^MATH(.B,.R,N,M)
 ;Reduction of matrix A, steps of reduction are counted by index K
 for K=1:1:N-1 do
 . ; Search for largest coefficient of T
 . ; (denoted by TEMP)
 . ; in first column of reduced system
 . set TEMP=0,J2=K
 . for J1=K:1:N do
 . . quit:$translate($get(T(J1,K)),"-")>$translate(TEMP,"-")
 . . set TEMP=T(J1,K),J2=J1
 . . quit
 . ;Exchange row number K with row number J2, if necessary
 . do:J2'=K
 . . for J=K:1:N do
 . . . set T1=$get(T(K,J)),T2=$get(T(J2,J))
 . . . kill T(K,J),T(J2,J)
 . . . if T1'="" set T(J2,J)=T1
 . . . if T2'="" set T(K,J)=T2
 . . . quit
 . . for J=1:1:M do
 . . . set T1=$get(R(K,J)),T2=$get(R(J2,J))
 . . . kill R(K,J),R(J2,J)
 . . . if T1'="" set R(J2,J)=T1
 . . . if T2'="" set R(K,J)=T2
 . . . quit
 . . quit
 . ;Actual reduction
 . for I=K+1:1:N do
 . . for J=K+1:1:N do
 . . . quit:'$get(T(K,K))
 . . . set T(I,J)=-$get(T(K,J))*$get(T(I,K))/T(K,K)+$get(T(I,J))
 . . . quit
 . . for J=1:1:M do
 . . . quit:'$get(T(K,K))
 . . . set R(I,J)=-$get(R(K,J))*$get(T(I,K))/T(K,K)+$get(R(I,J))
 . . . quit
 . . quit
 . quit
 ;Backsubstitution
 for J=1:1:M do
 . if $get(T(N,N)) set R(N,J)=$get(R(N,J))/T(N,N)
 . if N-1>0 for I1=1:1:N-1 do
 . . set I=N-I1
 . . for L=I+1:1:N do
 . . . set R(I,J)=-$get(T(I,L))*$get(R(L,J))+$get(R(I,J))
 . . . quit
 . . if $get(T(I,I)) set R(I,J)=$get(R(I,J))/$get(T(I,I))
 . . quit
 . quit
 ;;;QUIT $$MTXDET^MATH(.R)
 ; Ed de Moel, 29 Aug 1999
 quit $select(M=N:$$MTXDET^MATH(.R,M),1:1)
 ;;;
;---
MTXINV ;
 ;Invert A[N,N], result goes to R[N,N]
 if $data(A)<10 quit 0
 if $get(N)<1   quit 0
 new T,X
 set X=$$MTXUNIT^MATH(.T,N)
 quit $$MTXEQU^MATH(.A,.T,.R,N,N)
;---
MTXMUL ;
 ;Multiply A[M,L] by B[L,N], result goes to R[M,N]
 if $data(A)<10 quit 0
 if $data(B)<10 quit 0
 if $get(L)<1   quit 0
 if $get(M)<1   quit 0
 if $get(N)<1   quit 0
 new I,J,K,SUM,ANY
 for I=1:1:M for J=1:1:N do
 . set (SUM,ANY)=0
 . do KVALUE^MATH(.R,I,J)
 . for K=1:1:L do
 . . set:$data(A(I,K))#2 ANY=1
 . . set:$data(B(K,J))#2 ANY=1
 . . set SUM=$get(A(I,K))*$get(B(K,J))+SUM
 . . quit
 . set:ANY R(I,J)=SUM
 . quit
 quit 1
;---
MTXSCA ;
 ;Multiply A[ROWS,COLS] with the scalar S, result goes to R[ROWS,COLS]
 if $data(A)<10   quit 0
 if $get(ROWS)<1  quit 0
 if $get(COLS)<1  quit 0
 if '($data(S)#2) quit 0
 new ROW,COL
 for ROW=1:1:ROWS for COL=1:1:COLS do
 . do KVALUE^MATH(.R,ROW,COL)
 . set:$data(A(ROW,COL))#2 R(ROW,COL)=A(ROW,COL)*S
 . quit
 quit 1
;---
MTXSUB ;
 ;Subtract B[ROWS,COLS] from A[ROWS,COLS], result goes to R[ROWS,COLS]
 if $data(A)<10  quit 0
 if $data(B)<10  quit 0
 if $get(ROWS)<1 quit 0
 if $get(COLS)<1 quit 0
 new ROW,COL,ANY
 for ROW=1:1:ROWS for COL=1:1:COLS do
 . do KVALUE^MATH(.R,ROW,COL) set ANY=0
 . set:$data(A(ROW,COL))#2 ANY=1
 . set:$data(B(ROW,COL))#2 ANY=1
 . ;
 . ;;; set:ANY R(ROW,COL)=$get(A(ROW,COL)-$get(B(ROW,COL)) ; Number ~~
 . ; Eli Reidler (28 June 1996)
 . set:ANY R(ROW,COL)=$get(A(ROW,COL))-$get(B(ROW,COL))
 . ;;;
 . ;
 . quit
 quit 1
;---
MTXTRP ;
 ;Transpose A[M,N], result goes to R[N,M]
 if $data(A)<10 quit 0
 if $get(M)<1   quit 0
 if $get(N)<1   quit 0
 new I,J,K,D1,V1,D2,V2
 for I=1:1:M+N-1 for J=1:1:I+1\2 do
 . set K=I-J+1
 . if K=J do  quit
 . . set V1=$get(A(J,J)),D1=$data(A(J,J))#2
 . . if J'>N,J'>M do KVALUE^MATH(.R,J,J) set:D1 R(J,J)=V1
 . . quit
 . ;
 . set V1=$get(A(K,J)),D1=$data(A(K,J))#2
 . set V2=$get(A(J,K)),D2=$data(A(J,K))#2
 . if K'>M,J'>N do KVALUE^MATH(.R,K,J) set:D2 R(K,J)=V2
 . if J'>M,K'>N do KVALUE^MATH(.R,J,K) set:D1 R(J,K)=V1
 . quit
 quit 1
;---
MTXUNIT ;
 ;Create a unit matrix R[N,N]
 if $get(N)<1 quit 0
 new ROW,COL
 for ROW=1:1:N for COL=1:1:N do
 . do KVALUE^MATH(.R,ROW,COL)
 . if $get(SPARSE) quit:ROW'=COL
 . set R(ROW,COL)=$select(ROW=COL:1,1:0)
 . quit
 quit 1

MATH4
MATH4 ;
;---
PI new prec,pi
 set prec=^$job($job,"precision")
 set pi=3+$extract(.1415926535897932384626433832795028841971693993751058209749445923,1,prec+2)
 if prec=0 quit 3
 if prec=64 quit pi
 quit $extract(pi,1,$length(pi)-2)_($extract(pi,$length(pi)-1)+$select($extract(pi,$length(pi))>4:1,1:0))
;---
PRODUCE ;
 new VALUE,AGAIN,P1,P2,I,COUNT
 set VALUE=IN,COUNT=0
 for  do  quit:'AGAIN
 . set AGAIN=0
 . set I=""
 . for  set I=$order(SPEC(I)) quit:I=""  do  quit:COUNT<0
 . . quit:$get(SPEC(I,1))=""
 . . quit:'($data(SPEC(I,2))#2)
 . . for  quit:VALUE'[SPEC(I,1)  do  quit:COUNT<0
 . . . set P1=$piece(VALUE,SPEC(I,1),1)
 . . . set P2=$piece(VALUE,SPEC(I,1),2,$length(VALUE))
 . . . set VALUE=P1_SPEC(I,2)_P2,AGAIN=1
 . . . set COUNT=COUNT+1
 . . . if $data(MAX),COUNT>MAX set COUNT=-1,AGAIN=0
 . . . quit
 . . quit
 . quit
 quit VALUE
;---
RADDEG quit X*180/$$PI^MATH()
;---
REPLACE ;
 new L,MASK,K,I,LT,F,VALUE
 set L=$length(IN),MASK=$justify("",L)
 set I="" for  set I=$order(SPEC(I)) quit:I=""  do
 . quit:'($data(SPEC(I,1))#2)
 . quit:SPEC(I,1)=""
 . quit:'($data(SPEC(I,2))#2)
 . set LT=$length(SPEC(I,1))
 . set F=0 for  set F=$find(IN,SPEC(I,1),F) quit:F<1  do
 . . quit:$extract(MASK,F-LT,F-1)["X"
 . . set VALUE(F-LT)=SPEC(I,2)
 . . set $extract(MASK,F-LT,F-1)=$translate($justify("",LT)," ","X")
 . . quit
 . quit
 set VALUE="" for K=1:1:L do
 . if $extract(MASK,K)=" " set VALUE=VALUE_$extract(IN,K) quit
 . set:$data(VALUE(K)) VALUE=VALUE_VALUE(K)
 . quit
 quit VALUE
;---
SEC ;
 new L,LIM,K,SIGN,VALUE
 ;;; set:X[":" X=$$DMSDEC^MATH(X,12) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: The official description does not mention than
 ;          the function may also be called with the first
 ;          parameter in degrees, minutes and seconds.
 set:X[":" X=$$DMSDEC^MATH(X)
 ;;;
 set PREC=$get(PREC,11)
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=1,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=2:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L*X*X/(K-1*K),VALUE=VALUE+(SIGN*L)
 . quit
 if 'VALUE quit "INFINITE"
 quit 1/VALUE
;---
SECH ;;;Quit 1/$$COSH^MATH(X,PREC) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Alan Frank (October 1995)
 quit 1/$$COSH^MATH(X,$get(PREC,11))
 ;;;
;---
SIGN quit $select(X<0:-1,X>0:1,1:0)
;---
SIN ;
 ;;; ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: This version of the function is
 ;          optimized for speed, not for precision.
 ;          The 'precision' parameter is not supported,
 ;          and the precision is at best 1 in 10**-9.
 ;          Note that this function does not accept its
 ;          parameter in degrees, minutes and seconds.
 ;;;
 new A,N,PI,R,SIGN,XX
 ;This approximation only works for 0 <= x <= pi/2 so reduce angle to correct quadrant.
 set PI=$$PI^MATH(),X=X#(PI*2),SIGN=1
 set:X>PI X=2*PI-X,SIGN=-1
 ;;; set:X*2<PI X=PI-X set X=-PI/2+2 ; Number ~~
 ; Winfried Gerum (8 June 1995)
 set:X*2<PI X=PI-X
 ;;;
 set XX=X*X,A(1)=-0.4999999963,A(2)=0.0416666418
 set A(3)=-0.0013888397,A(4)=0.0000247609,A(5)=-0.0000002605
 set (X,R)=1 for N=1:1:5 set X=X*XX,R=A(N)*X+R
 quit R*SIGN
;---
SINX ;
 new L,LIM,K,SIGN,VALUE
 ;;; set:X[":" X=$$DMSDEC^MATH(X,12) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: The official description does not mention than
 ;          the function may also be called with the first
 ;          parameter in degrees, minutes and seconds.
 set:X[":" X=$$DMSDEC^MATH(X)
 ;;;
 set PREC=$get(PREC,11)
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=X,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L/(K-1)*X/K*X,VALUE=VALUE+(SIGN*L)
 . quit
 quit VALUE
;---
SINH ;
 ;;; New F,I,P,R,T,XX ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 new E,F,I,P,R,T,XX
 ;;;
 set PREC=$get(PREC,11)+1
 set @("E=1E-"_PREC)
 set XX=X*X,F=1,I=2,(P,R,T)=X
 for  set T=T*XX,F=I+1*I*F,R=T/F+R,P=P-R/R,I=I+2 if -E<P,P<E quit
 quit R
;---
SQRT ;
 if X<0 set $ecode=",M28,"
 if X=0 quit 0
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 ;;; if X<1 quit 1/$$SQRT^MATH(1/X) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 if X<1 quit 1/$$SQRT^MATH(1/X,PREC)
 ;;;
 new P,R,E
 set PREC=$get(PREC,11)+1
 ;;; set @(E="1E-"_PREC) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Eli Reidler (28 June 1996)
 set @("E=1E-"_PREC)
 ;;;
 set R=X
 for  set P=R,R=X/R+R/2,P=P-R/R if -E<P,P<E quit
 quit R

MATH5
MATH5 ;
;---
TAN ;
 new L,LIM,K,S,SIGN,VALUE
 ;;; set:X[":" X=$$DMSDEC^MATH(X,12) ; Number ~~
 ; Winfried Gerum (8 June 1995)
 ; Comment: The official description does not mention than
 ;          the function may also be called with the first
 ;          parameter in degrees, minutes and seconds.
 set:X[":" X=$$DMSDEC^MATH(X)
 ;;;
 set PREC=$get(PREC,11)
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=X,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=3:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L/(K-1)*X/K*X,VALUE=VALUE+(SIGN*L)
 . quit
 set S=VALUE
 set X=X#(2*$$PI^MATH())
 set (VALUE,L)=1,SIGN=-1
 set LIM=$select((PREC+3)'>11:PREC+3,1:11),@("LIM=1E-"_LIM)
 for K=2:2 do  quit:($translate(L,"-")<LIM)  set SIGN=SIGN*-1
 . set L=L*X*X/(K-1*K),VALUE=VALUE+(SIGN*L)
 . quit
 if 'VALUE quit "INFINITE"
 quit S/VALUE
;---
TANH ;
 ;;; ; Number ~~
 ; Alan Frank (October 1995)
 set PREC=$get(PREC,11)
 ;;;
 quit $$SINH^MATH(X,PREC)/$$COSH^MATH(X,PREC)
;---
FORMAT ;
 ;The code below was approved in document X11/SC13/TG2/1999-1
 new lo,mask,out,p,pos,spec,up,v1,v2,val,x
 set lo="abcdefghijklmnopqrstuvwxyz"
 set up="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 ;Array spec() contains the formatting directives
 ;First set defaults
 set spec("CS")="$" ;Currency symbol
 set spec("DC")="." ;Decimal separator
 set spec("EC")="*" ;Error character
 set spec("SL")="," ;Separator characters > 1
 set spec("FS")=" " ;Fill string
 ; Other specifiers may be
 ; FM = Format Mask
 ; FO = Fill On/Off
 ; SR = Separator characters < 1
 ; Then Inherit properties from System,
 ; overwriting the defaults
 ; DLW - ^$system($system,"format",...) is not supported in RSM
 set x="" for  set x=$order(^$system($system,"format",x)) quit:x=""  do
 . set spec(x)=^$system($system,"format",x)
 . quit
 ;Then Inherit properties from current process overwriting the system and the defaults
 set x="" for  set x=$order(^$job($job,"format",x)) quit:x=""  do
 . set spec(x)=^$job($job,"format",x)
 . quit
 ;Then look at actual parameters overwriting anything else
 set S=$get(S) for  quit:S=""  do
 . new e,i,str,v
 . set x=$piece(S,"=",1)
 . set i=$length(x)+2,str=0,v=""
 . set:x="" i=1
 . for i=i:1:$length(S)+1 do  quit:'i
 . . set e=$extract(S_":",i)
 . . if 'str,e=":" set S=$extract(S,i+1,$length(S)),i=0 quit
 . . set v=v_e quit:e'=""""
 . . set str=1-str
 . . quit
 . if i>$length(S) set S=""
 . if x'="",v'="" set @("spec($translate(x,lo,up))="_v) quit
 . set $ecode=",M28,"
 . quit
 ;Make certain that DC and EC are non-empty and not longer than 1 character
 set spec("DC")=$extract(spec("DC")_".",1)
 set spec("EC")=$extract(spec("EC")_"*",1)
 set val=$get(V),(mask,out)=$get(spec("FM"))
 if mask="" quit val
 ;Currency string
 set x=spec("CS")
 set pos=0 for  set pos=$find(mask,"c",pos) quit:pos<1  do
 . set $extract(out,pos-1)=$extract(x,1)
 . set x=$extract(x,2,$length(x))_$extract(x,1)
 . quit
 ;Sign
 set x=$select(val>0:"+",val<0:"-",1:" ")
 set pos=0 for  set pos=$find(mask,"+",pos) quit:pos<1  do
 . set $extract(out,pos-1)=x
 . quit
 set pos=0 for  set pos=$find(mask,"-",pos) quit:pos<1  do
 . set $extract(out,pos-1)=$select(x="-":x,1:" ")
 . quit
 if x'="-" set out=$translate(out,"()","  ")
 ;Decimal separator
 set pos=$find(mask,"d")
 do:pos'<1
 . set $extract(out,pos-1)=spec("DC")
 . for  set pos=$find(mask,"d",pos) quit:pos<1  do
 . . set $extract(out,pos-1)=spec("EC")
 . . quit
 . quit
 ;Right (default, format letter "n") or left (format letter "l") adjustment?
 if mask["l",mask["n" set $ecode=",M28,"
 ;Left and Right Separators
 set v1=$piece(val,".",1),v2=$piece(val,".",2)
 set v1=$translate(v1,"-")
 if mask'["l" do
 . set x="" for p=1:1:$length(v1) set x=$extract(v1,p)_x
 . set v1=x
 . quit
 set pos=$find(mask,"d") set:pos<1 pos=$length(mask)+2
 ;Integer part and Left separators
 set x=spec("SL")
 set p(1)=pos-2,p(2)=-1,p(3)=1
 set:mask["l" p(1)=1,p(2)=1,p(3)=pos-2
 for p=p(1):p(2):p(3) do
 . if "fln"[$extract(mask,p) do
 . . set $extract(out,p)=$extract(v1,1)
 . . set v1=$extract(v1,2,$length(v1))_spec("FS")
 . . if $translate(v1,spec("FS"))="" set x=spec("FS")
 . . quit
 . if $extract(mask,p)="s" do
 . . set $extract(out,p)=$extract(x,1)
 . . set x=$extract(x,2,$length(x))_$extract(x,1)
 . quit
 ;Fractional part and Right separators
 set x=$get(spec("SR"),spec("SL"))
 set:v2="" v2=0
 for p=pos:1:$length(mask) do
 . if "fn"[$extract(mask,p) do
 . . set $extract(out,p)=$extract(v2,1)
 . . set v2=$extract(v2,2,$length(v2))_"0"
 . . quit
 . if $extract(mask,p)="s" do
 . . set $extract(out,p)=$extract(x,1)
 . . set x=$extract(x,2,$length(x))_$extract(x,1)
 . . quit
 . quit
 ;Fill String
 set x=$get(spec("FS"))
 for p=1:1:$l(mask) do
 . quit:"nf"'[$extract(mask,p)
 . quit:$extract(out,p)'=" "
 . set $extract(out,p)=$extract(x,1)
 . set x=$extract(x,2,$length(x))_$extract(x,1)
 . quit
 ;Justification
 for x="+ | +","- | -","( | ("," )|) " do
 . new find,repl
 . set find=$piece(x,"|",1),repl=$piece(x,"|",2)
 . for  quit:out'[find  do
 . . set out=$piece(out,find,1)_repl_$piece(out,find,2,$l(out)+2)
 . . quit
 . quit
 quit out

MATH6
MATH6 ;
;---
XOR new I,M,R
 set R=b,M=1
 for I=1:1:w do
 . set:a\M#2 R=R+$select(R\M#2:-M,1:M)
 . set M=M+M
 . quit
 quit R
;---
CRC16 ;
 ; The code below was approved in document X11/1998-32
 ; Polynomial x**16 + x**15 + x**2 + x**0
 new I,J,R
 if '$data(seed) set R=0
 else  if seed'<0,seed'>65535 set R=seed\1
 else  set $ecode=",M28,"
 for I=1:1:$length(string) do
 . set R=$$XOR($ascii(string,I),R,8)
 . for J=0:1:7 do
 . . if R#2 set R=$$XOR(R\2,40961,16)
 . . else  set R=R\2
 . . quit
 . quit
 quit R
;---
CRC32 ;
 ; The code below was approved in document X11/1998-32
 ; Polynomial X**32 + X**26 + X**23 + X**22 +
 ;          + X**16 + X**12 + X**11 + X**10 +
 ;          + X**8  + X**7  + X**5  + X**4 +
 ;          + X**2  + X     + 1
 new I,J,R
 if '$data(seed) set R=4294967295
 else  if seed'<0,seed'>4294967295 set R=4294967295-seed
 else  set $ecode=",M28,"
 for I=1:1:$length(string) do
 . set R=$$XOR($ascii(string,I),R,8)
 . for J=0:1:7 do
 . . if R#2 set R=$$XOR(R\2,3988292384,32)
 . . else  set R=R\2
 . . quit
 . quit
 quit 4294967295-R
;---
CRCCCITT ;
 ; The code below was approved in document X11/1998-32
 ; Polynomial x**16 + x**12 + x**5 + x**0
 new I,J,R
 if '$data(seed) set R=65535
 else  if seed'<0,seed'>65535 set R=seed\1
 else  set $ecode=",M28,"
 for I=1:1:$length(string) do
 . set R=$$XOR($ascii(string,I)*256,R,16)
 . for J=0:1:7 do
 . . set R=R+R
 . . quit:R<65536
 . . set R=$$XOR(4129,R-65536,13)
 . . quit
 . quit
 quit R
;---
LOWER new lo,up,x,y
 ; The code below was approved in document X11/1998-21
 set x=$get(CHARMOD)
 set lo="abcdefghijklmnopqrstuvwxyz"
 set up="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 if x?1"^"1E.E do
 . set x=$extract(x,2,$length(x))
 . if x?1"|".E do
 . . set x=$reverse($extract(x,2,$length(x)))
 . . set y=$reverse($piece(x,"|",2,$length(x)+2))
 . . set x=$reverse($piece(x,"|",1))
 . . set x=$get(^[y]$global(x,"character"))
 . . quit
 . else  set x=$get(^$global(x,"character"))
 . quit
 if x="" set x=^$job($job,"character")
 ; DLW - RSM doesn't yet implement ^$character
 set x=$get(^$character(x,"lower"))
 if x="" quit $translate(A,up,lo)
 set @("x="_x_"(A)")
 quit x
;---
PATCODE new x,y
 ; The code below was approved in document X11/1998-21
 set x=$get(CHARMOD)
 if x?1"^"1E.E do
 . set x=$extract(x,2,$length(x))
 . if x?1"|".E do
 . . set x=$reverse($extract(x,2,$length(x)))
 . . set y=$reverse($piece(x,"|",2,$length(x)+2))
 . . set x=$reverse($piece(x,"|",1))
 . . set x=$get(^[y]$global(x,"character"))
 . . quit
 . else  set x=$get(^$global(x,"character"))
 . quit
 if x="" set x=^$job($job,"character")
 ; DLW - RSM doesn't yet implement ^$character
 set x=$get(^$character(x,"patcode",PAT))
 if x="" quit 0
 set @("x="_x_"(A)")
 quit x
;---
UPPER new lo,up,x,y
 ; The code below was approved in document X11/1998-21
 set x=$get(CHARMOD)
 set lo="abcdefghijklmnopqrstuvwxyz"
 set up="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 if x?1"^"1E.E do
 . set x=$extract(x,2,$length(x))
 . if x?1"|".E do
 . . set x=$reverse($extract(x,2,$length(x)))
 . . set y=$reverse($piece(x,"|",2,$length(x)+2))
 . . set x=$reverse($piece(x,"|",1))
 . . set x=$get(^[y]$global(x,"character"))
 . . quit
 . else  set x=$get(^$global(x,"character"))
 . quit
 if x="" set x=^$job($job,"character")
 ; DLW - RSM doesn't yet implement ^$character
 set x=$get(^$character(x,"upper"))
 if x="" quit $translate(A,lo,up)
 set @("x="_x_"(A)")
 quit x

MUMTRIS
MUMTRIS ;Convert for MUMPS V1 - RDN, and RSM ;V 3.011 09 Jun 2012 11:28 AM
; Mumtris
; Copyright (C) 2012 Piotr Koper <piotr.koper@gmail.com>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU Affero General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
; GNU Affero General Public License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with this program. If not, see <http://www.gnu.org/licenses/>.
;
; Mumtris
; This is a tetris game in MUMPS, for GT.M, have fun.
;
; Resize your terminal (e.g. maximize your PuTTY window), restart GT.M so that
; it can report true size of your terminal, and do ^mumtris.
;
; Try setting ansi=0 for GT.M compatible cursor positioning.
;
; NOTICE: Mumtris uses "active waiting" for making delays lower that 1s.
;         That means that one of your CPU will be used at 99%. It's not a bug,
;         the Mumtris and GT.M will be fully responsive. Take care when
;         running on production system ;-)
mumtris ;
 new ansi,e,n,w,h,gr,fl,hl,sc,lv,lc,sb,st,ml,dh,dw,mx,my,mt,r,y,x,t10m,c,ne,i,q
 set ansi=1          ;use (faster) ANSI CSI instead of use $principal:X=x positioning
 set w=10            ;matrix width
 set h=22            ;matrix height (see below)
 set gr=1            ;grid
 set fl=1            ;fill
 set hl=1            ;help
 set sc=0            ;score
 set lv=1            ;level
 set lc=0            ;lines cleared at current level
 set sb=40           ;step base
 set st=$$step       ;current step
 set ml=3            ;move/rotate hold limit (without fall)
 do dev              ;defines dw, dh (device width, device height)
 set h=dh-2          ;comment out to disable auto height
 set mx=dw/2-(3*w/2) ;matrix left coordinate
 set my=dh/2-(h/2)-1 ;matrix top coordinate
 set mt="3 5_9 8 2_9 .2_02 /5 \2 2_ 2_2 6_/2 |8_|2_| 6_0 /2 \ /2 \|2 |2 \/5 \3 2_\_2 2_ \2 |/2 3_/0/4 Y4 \2 |2 /2 Y Y2 \2 |2 |2 | \/2 |\3_ \0\4_|2_2 /4_/|2_|_|2 /2_|2 |2_|2 |2_/4_2 >08 \/9 3 \/9 9 2 \/0" ;Mumtris
 ;use $principal:"noecho" do cls
 use $principal do cls
 do intro
 do elements
 set ne=$random(e)+1 ;new element
 do change do new() do preview
 do score() do help do redraw
 set (i,q)=0
 for  quit:q  do
 . do pos(0,0)
 . set c=$$key
 . if c=1 do exit set q=1 quit
 . set i=$select('c:0,1:i+1)
 . set:i'<ml (i,c)=0
 . if c'=3&$$fall do lock do clear do change do preview if $$new do over do exit set q=1 quit
 . do redraw
 quit
;---
key() ;1 - exit, 2 - harddrop, 3 - other char
 new q,c,d,ex,hd
 set (q,d,ex,hd)=0
 new i
 new l set l=1
 for  quit:q  do
 . read *c:0
 . if c<0&'d do
 . . for i=1:1:st*t10m read *c:0 quit:c>0  if $horolog
 . if c<0 set q=1 quit
 . set d=2
 . if c=27 do  quit:q
 . . read *c:0 if c<0 set (q,ex)=1 quit
 . . if c=91 read *c:0
 . do:c=65 rotate
 . do:c=66 fall(1)
 . do:c=67 right
 . do:c=68 left
 . if c=70!(c=102) set fl=fl+1#3 do preview
 . set:c=71!(c=103) gr='gr
 . if c=72!(c=104) set hl='hl do help
 . set:c=81!(c=113) (q,ex)=1
 . if c=32 do drop set hd=1
 quit $select(ex:1,hd:2,d:3,1:0)
;---
redraw ;
 do matrix
 do stack
 do draw(n,r,y,x)
 quit
;---
ticks ;
 new h,b,e,q
 set h=$horolog,(b,e,q)=0 for i=1:1:1000000000 if h'=$horolog set h=$horolog do  quit:q
 . if 'b set b=i
 . else  set e=i,q=1
 set t10m=(e-b)\100
 quit
;---
delay(d) ;
 new i for i=1:1:t10m*d if $horolog
 quit
;---
change ;
 set n=ne
 set ne=$random(e)+1
 set x=0,y=0,r=1
 quit
;---
new() ;
 set r=1,x=w/2-2,y=1-e(n,r)
 quit:$quit $$collision(r,y,x) quit
;---
drop ;
 new i
 set i=0 for  quit:$$fall  set i=i+2
 do score(i)
 quit
;---
rotate ;
 new k
 set k=r#e(n)+1
 quit:$$collision(k,y,x)
 set r=k
 quit
;---
fall(k) ;
 new c
 if $$collision(r,y+1,x) quit:$quit 1 quit
 set y=y+1
 do:$get(k) score(1)
 quit:$quit 0 quit
;---
right quit:$$collision(r,y,x+1)  set x=x+1 quit
;---
left quit:$$collision(r,y,x-1)  set x=x-1 quit
;---
collision(r,y,x) ;
 new i,j,q
 set q=0
 for i=1:1:4 quit:q  for j=1:1:4 quit:q  set:$get(e(n,r,j,i))&($get(n(y+j,x+i))!(y+j>h!(x+i>w!(x+i<1)))) q=1
 quit q
;---
lock ;
 new i,j
 for i=1:1:4 quit:q  for j=1:1:4 quit:q  set:$get(e(n,r,j,i)) n(y+j,x+i)=1
 quit
;---
clear ;
 new c,i,j,q
 set c=0
 for j=h:-1:1 do
 . set q=0
 . for i=1:1:w if '$get(n(j,i)) set q=1 quit
 . quit:q
 . for i=j:-1:1 kill n(i) m n(i)=n(i-1)
 . set j=j+1,c=c+1
 . do redraw
 if c do
 . do score($select(c=4:800,1:i*200-100*lv))
 . set lc=lc+c
 . if lv*10'>lc do score(,1) set lc=0
 quit
;---
exit ;
 new s
 set s=mt_"09  Piotr Koper <piotr.koper@gmail.com>09 8 h2tps:2/github.com/pkoper"
 do cls do write(.s,dh/2-3,dw/2-24) hang 1 read *s:0 read *s:4
 do cls use $principal:"echo"
 quit
;---
intro ;
 new s
 set s=mt_"9 9 8 Mumtris for GT.M0"
 do cls hang 1 do write(.s,dh/2-3,dw/2-24) hang 1
 do ticks
 do cls
 read s:0
 quit
;---
cls ;
 do pos(0,0,1)
 quit
;---
pos(y,x,c) ;
 if ansi do
 . ;workaround for ANSI driver: NL in some safe place (1,1)
 . write $char(27)_"[1;1f",!,$char(27)_"["_(y+1)_";"_(x+1)_"f"
 . write:$get(c) $char(27)_"[2J"
 else  do
 . use $principal:(x=x:y=y)
 . ; DLW - clearscreen is not defined
 . use:$get(c) $principal:clearscreen
 quit
;---
over ;
 new s
 set s="2 8_9 9 6 8_0 /2 5_/5_4 5_3 4_3 \5_2 \3_2 2_ 9_2_0/3 \2 3_\2_2 \2 /5 \_/ 2_ \3 /3 |3 \2 \/ 2/ 2_ \_2 2_ \0\4 \_\2 \/ 2_ \|2"
 set s=s_" Y Y2 \2 3_/2 /4 |4 \3 /\2 3_/|2 | \/0 \6_2 (4_2 /2_|_|2 /\3_2 > \7_2 /\_/2 \3_2 >2_|08 \/5 \/6 \/5 \/9  \/9  \/0"
 do cls do write(.s,dh/2-3,dw/2-32) hang 1 read *s:0 read *s:2
 quit
;---
write(s,y,x) ;
 new i,j,l,c,d
 do pos(y,x)
 set l=$l(s) for i=1:1:l do
 . set c=$e(s,i)
 . if c?1N do
 . . if 'c set y=y+1 do pos(y,x) quit
 . . set d=$e(s,i+1) for j=1:1:c write d
 . . set i=i+1
 . else  write c
 do pos(0,0)
 quit
;---
help ;
 new i,x,l,j
 set i=9
 for x="MOVE: LEFT, RIGHT","TURN: UP","DROP: SPACE","","FILL: F","GRID: G","HELP: H","","QUIT: ESC, Q" do
 . set i=i+1 do pos(dh/2-(h/2)+i,dw/2+(3*w/2+3)) do
 . . if hl write x
 . . else  set l=$l(x) for j=1:1:l write " "
 quit
;---
fill() quit $select(fl=1:"[#]",fl=2:"[+]",1:"[ ]")
;---
draw(n,r,y,x,o) ;
 new i,j
 set x=3*x+mx+1,y=y+my
 for i=1:1:4 if y+i>my for j=1:1:4 write $select($get(e(n,r,i,j)):$$fill,$get(o):"   ",1:"")
 ;;f i=1:1:4 i y+i>my use $p:y=y+i-1 f j=1:1:4 u $p:(x=3*(j-1)+x) w $s($g(e(n,r,i,j)):$$fill,$g(o):"   ",1:"")
 ;;                   ^^^^^^^^^^^^^^ what does that mean?
 quit
;---
step() quit 0.85**lv*sb+(0.1*lv)
;---
score(s,l) ;
 set:$get(s) sc=sc+s
 if $get(l) set lv=lv+l,st=$$step
 do pos(dh/2-(h/2)+2,dw/2+(3*w/2+3)) write "SCORE: ",sc
 do pos(dh/2-(h/2)+3,dw/2+(3*w/2+3)) write "LEVEL: ",lv
 quit
;---
preview ;
 do draw(ne,1,3,-5,1)
 quit
;---
stack ;
 new i,j,x,y
 set x=mx+1,y=my
 for i=1:1:h for j=1:1:w if $get(n(i,j)) do pos(y+i-1,3*(j-1)+x) write $$fill
 quit
;---
matrix ;
 new i,j
 for i=0:1:h-1 do
 . do pos(my+i,mx) write "|" for j=1:1:w write $select(gr:" . ",1:"   ")
 . write "|"
 do pos(my+h,mx) write "|" for j=1:1:w*3 write "~"
 write "|",!
 quit
;---
dev ;
 ;I +$system=50 set dw=80,dh=24 quit  ;Assume for now
 ;n x,i
 ;zsh "d":x
 ;s i="" for  set i=$o(x("D",i)) quit:i=""  do:(x("D",i)[$p)
 ;. set dw=$p($p(x("D",i),"WIDTH=",2)," ",1),dh=$p($p(x("D",i),"LENG=",2)," ",1)
 new size
 set size=$&e($&%spawn("stty size",1),"c")
 set dh=$p(size," "),dw=$p(size," ",2)
 quit
;---
elements ;
 ; e - elements
 ; e(elemId) - rotateVersions
 ; e(elemId,rotateVersion) - bottom coordinate
 ; e(elemId,rotateVersion,y,x) - point
 set e=7
 ; ____
 set e(1)=2,e(1,1)=2
 set (e(1,1,2,1),e(1,1,2,2),e(1,1,2,3),e(1,1,2,4))=1
 set (e(1,2,1,2),e(1,2,2,2),e(1,2,3,2),e(1,2,4,2))=1
 ; |__
 set e(2)=4,e(2,1)=2
 set (e(2,1,1,1),e(2,1,2,1),e(2,1,2,2),e(2,1,2,3))=1
 set (e(2,2,1,2),e(2,2,1,3),e(2,2,2,2),e(2,2,3,2))=1
 set (e(2,3,2,1),e(2,3,2,2),e(2,3,2,3),e(2,3,3,3))=1
 set (e(2,4,1,2),e(2,4,2,2),e(2,4,3,1),e(2,4,3,2))=1
 ; __|
 set e(3)=4,e(3,1)=2
 set (e(3,1,1,3),e(3,1,2,1),e(3,1,2,2),e(3,1,2,3))=1
 set (e(3,2,1,2),e(3,2,2,2),e(3,2,3,2),e(3,2,3,3))=1
 set (e(3,3,2,1),e(3,3,2,2),e(3,3,2,3),e(3,3,3,1))=1
 set (e(3,4,1,1),e(3,4,1,2),e(3,4,2,2),e(3,4,3,2))=1
 ; ||
 set e(4)=1,e(4,1)=2
 set (e(4,1,1,1),e(4,1,1,2),e(4,1,2,1),e(4,1,2,2))=1
 ; _-
 set e(5)=2,e(5,1)=3
 set (e(5,1,2,2),e(5,1,2,3),e(5,1,3,1),e(5,1,3,2))=1
 set (e(5,2,1,2),e(5,2,2,2),e(5,2,2,3),e(5,2,3,3))=1
 ; _|_
 set e(6)=4,e(6,1)=2
 set (e(6,1,1,2),e(6,1,2,1),e(6,1,2,2),e(6,1,2,3))=1
 set (e(6,2,1,2),e(6,2,2,2),e(6,2,2,3),e(6,2,3,2))=1
 set (e(6,3,2,1),e(6,3,2,2),e(6,3,2,3),e(6,3,3,2))=1
 set (e(6,4,1,2),e(6,4,2,1),e(6,4,2,2),e(6,4,3,2))=1
 ; -_
 set e(7)=2,e(7,1)=3
 set (e(7,1,2,1),e(7,1,2,2),e(7,1,3,2),e(7,1,3,3))=1
 set (e(7,2,1,2),e(7,2,2,1),e(7,2,2,2),e(7,2,3,1))=1
 quit

SSD
SSD ;Shutdown ;V 3.0 10 Oct 1999 06:23 PM
 set ^$system("vol",1,"writelock")=1 write !,"Writelocking the database"
 for  write "." quit:^$system("vol",1,"writelock")>0  hang 1
 write !,"Shutting Down.",! kill ^$job halt

UCI
UCI ;WAA-This routine will be for UCI management. 5/30/00
 ;It will allow the developer to create, edit, and delete UCIs.
 ;It will also display existiing UCIs
 new ENTER,MENU,OPT
;---
ENT do MNUDSP
 read !,?10,"Enter Option: ",ENTER quit:ENTER=""
 if ENTER'?1N write !,"ENTER THE NUMBER OF THE MENU OPTION...",*7 goto ENT
 if '$data(MENU(ENTER)) write !,"INVALID OPTION...",*7 goto ENT
 set OPT=$piece(MENU(ENTER),";",4) xecute OPT goto ENT
 quit
;---
MNUDSP ;Display menu
 new X
 set X=1
 write !,"UCI Management...",!
 for  set MENU=$text(MENU+X) quit:$piece(MENU,";",3)=""  set MENU(X)=MENU,X=X+1 do
 . write !,?20,$piece(MENU,";",3)
 . quit
 quit
;---
CREAT ;Create a UCI but not UCI 1 (manager)
 new NUCI,X,FLG,VOL,UCI
 set VOL=1,UCI=""
 do DISP("Create a UCI...",.VOL,.UCI)
;---
CR1 ;Prompt
 read !!,"Enter new UCI name: ",NUCI quit:NUCI=""
 if $get(^$system("name_length"),8)=32,NUCI'?1.32A write !,"INVALID UCI NAME??",*7 goto CR1
 if $get(^$system("name_length"),8)=8,NUCI'?1.8A write !,"INVALID UCI NAME??",*7 goto CR1
 set FLG=0
 for X=1:1:UCI if UCI(X)=NUCI write !,"CAN NOT NAME UCI THE SAME AS EXISTING UCI.",*7 set FLG=1 quit
 if FLG goto CR1
 set UCI=UCI+1,^$system("vol",VOL,"uci",UCI)=NUCI write !,NUCI," has been created..."
 do LIST^UCI
 quit
;---
EDIT ;Edit an existing UCI but not UCI 1 (manager)
 new HEAD,OUCI,NUCI,VOL,UCI,X,Y
 set VOL=1,UCI=""
 do DISP("Rename a UCI...",.VOL,.UCI)
;---
ED1 ;Edit prompt
 read !,"Select UCI to Edit: ",OUCI quit:OUCI=""
 if '$data(UCI(OUCI)) write !,"INVALID UCI??",*7 goto ED1
 if +OUCI=0 set OUCI=UCI(OUCI)
;---
ED2 ;Edit Prompt
 read !,"Enter New UCI Name: ",NUCI
 if $get(^$system("name_length"),8)=32,NUCI'?1.32A write !,"BAD UCI NAME??",*7 goto ED2
 if $get(^$system("name_length"),8)=8,NUCI'?1.8A write !,"BAD UCI NAME??",*7 goto ED2
 if $data(UCI(NUCI)) write !,"CANNOT USE NAME UCI ",NUCI," ALREADY EXISTS??",*7 goto ED2
 set ^$system("vol",VOL,"uci",OUCI)=NUCI write !,OUCI," has been renamed to ",NUCI,"..."
 do LIST
 quit
;---
DELETE ;Delete an existing UCI but not UCI 1 (manager)
 new DUCI,VOL,UCI
 set VOL=1,UCI=""
 do DISP("Delete a UCI...",.VOL,.UCI)
;---
DE1 ;Select Prompt
 read !,"Select UCI to DELETE: ",DUCI quit:DUCI=""
 if '$data(UCI(DUCI)) write !,"INVALID UCI??",*7 goto DE1
 if +DUCI=0 set DUCI=UCI(DUCI)
 if UCI(DUCI)=^$system("vol",1,"uci",1) write !,"CANNOT DELETE UCI 1 (MANAGER) ["_UCI(DUCI)_"]",*7 goto DE1
 kill ^$system("vol",VOL,"uci",DUCI)
 do LIST
 quit
;---
DISP(HEAD,VOL,UCI) ;Generic display of UCI
 new X,Z
 if HEAD="" quit
 if VOL="" set VOL=1
 set UCI=""
 write !,HEAD
 do LIST
 do GET(VOL,.UCI)
 for X=1:1:UCI set Z=UCI(X),UCI(Z)=X
 quit
;---
LIST ;List all UCIs within a Volume set
 new VOL,UCI,X
 set VOL=1,UCI=""
 write !,"User Class Identifiers [UCI] within the Volume set: ",^$system("vol",VOL,"name")
 write !,?10,"UCI#",?40,"UCI"
 write !,?10,"----",?40,"---"
 do GET(VOL,.UCI)
 for X=1:1:UCI write !,?10,X,?40,UCI(X)
 quit
;---
GET(VOL,UCI) ;Build an array of all the UCIs within the VOLUME Set.
 new X
 set UCI=0
 quit:VOL'>0  set X=0
 for  set X=$order(^$system("vol",VOL,"uci",X)) quit:X<1  set UCI=X,UCI(X)=^$system("vol",VOL,"uci",X)
 quit
;---
MENU ;Menu List
 ;;1) List UCI;D LIST
 ;;2) Create UCI;D CREAT
 ;;3) Edit UCI;D EDIT
 ;;4) Delete UCI;D DELETE
 ;;


; Package:  Reference Standard M
; File:     rsm/utils.rsm
; Summary:  Impementation of the M Language and Database System
;
; David Wicksell <dlw@linux.com>
; Copyright (c) 2020-2022 Fourth Watch Software LC
; https://gitlab.com/Reference-Standard-M/rsm
;
; Based on MUMPS V1 by Raymond Douglas Newman
; Copyright (c) 1999-2018
; https://gitlab.com/Reference-Standard-M/mumpsv1
;
; This program is free software: you can redistribute it and/or modify it
; under the terms of the GNU Affero General Public License (AGPL) as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
; or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
; License for more details.
;
; You should have received a copy of the GNU Affero General Public License
; along with this program. If not, see http://www.gnu.org/licenses/.
